## app/__init__.py
from .core import server
from .api import *

## Program entry point for wsgi server
app = server.app

## app/utils/config_helpers.py
import yaml
from datetime import timedelta

def parse_duration(duration_config):
    """
    Parse a duration configuration and return the total duration in seconds.
    """
    months = duration_config.get("months", 0)
    days = duration_config.get("days", 0)
    hours = duration_config.get("hours", 0)
    minutes = duration_config.get("minutes", 0)
    seconds = duration_config.get("seconds", 0)

    # Convert months to days (approximate, assuming 30 days per month)
    total_days = months * 30 + days

    # Calculate total duration in seconds
    total_seconds = (
        total_days * 86400 +
        hours * 3600 +
        minutes * 60 +
        seconds
    )

    return total_seconds


def get_property(config:dict, property_name:str, sub_propertyList:list[str]=None, type:str="Time"):
    """
    Get the value of a property from a YAML file.

    Args:
        config (dict): The configuration dictionary. (YAML file loaded as a dictionary)
        property_name (str): The name of the property to retrieve.
        sub_propertyList (list[str], optional): The list of sub-properties to retrieve. Defaults to None.
        type (str, optional): The type of the property. Defaults to "Time".
    """
    if sub_propertyList:
        return_dict = {}
        work_config:dict = config.get(property_name)
        for sub_property in sub_propertyList:
            if type == "Time":
                prop_config:dict = work_config.get(sub_property)
                if not prop_config or not isinstance(prop_config, dict):
                    continue
                return_dict[sub_property] = parse_duration(prop_config)
            else:
                return_dict[sub_property] = work_config.get(sub_property)
        return return_dict
    else:
        return config.get(property_name)

# # Example usage
# if __name__ == "__main__":
#     with open("./config/config.yaml", "r") as file:
#         config = yaml.safe_load(file)

#     # Get the duration of the access token
#     token_duration = get_property(config, "auth", ["access_token_duration", "refresh_token_duration"])
#     print(f"access token duration: {token_duration['access_token_duration']} seconds")
#     print(f"refresh token duration: {token_duration['refresh_token_duration']} seconds")

#     # Get the mail server configuration
#     mail_server_config = get_property(config, "verify", ["email_verification_code_duration", "acc_recovery_code_duration"])
#     print(f"email verification code duration: {mail_server_config['email_verification_code_duration']} seconds")
#     print(f"password reset code duration: {mail_server_config['acc_recovery_code_duration']} seconds")

## app/utils/patterns.py

def singleton(cls):
    """A singleton decorator. Garantees that only one instance of the class is created."""
    instances = {}
    def getinstance():
        if cls not in instances:
            instances[cls] = cls()
        return instances[cls]
    return getinstance


## app/utils/__init__.py
from .config_helpers import *
from .patterns import *

## app/utils/image_handler.py
import io
from typing import Optional, BinaryIO, AsyncGenerator
import asyncio
from fastapi import UploadFile, HTTPException, status
from fastapi.responses import StreamingResponse

from PIL import Image, UnidentifiedImageError
import pillow_avif
from sqlalchemy.ext.asyncio import AsyncSession
import asyncpg
from asyncpg import Connection

from ..core.picture_config import picture_config, get_allowed_mime_types, is_mime_type_allowed
from ..db.postgress.postgress_pool import init_pg_pool

# Get configuration values
CHUNK_SIZE = picture_config.chunk_size
MAX_IMAGE_SIZE = picture_config.max_size
ALLOWED_MIME_TYPES = get_allowed_mime_types()
AVIF_QUALITY = picture_config.avif_quality
MAX_WIDTH = picture_config.max_width
MAX_HEIGHT = picture_config.max_height
MIN_WIDTH = picture_config.min_width
MIN_HEIGHT = picture_config.min_height

async def validate_image(file: UploadFile, max_size: int = MAX_IMAGE_SIZE) -> None:
    """
    Validate an uploaded image file (type and size).

    Args:
        file: The uploaded file
        max_size: Maximum allowed file size in bytes

    Raises:
        HTTPException: If the file is not valid
    """
    # Check if file is an image
    if not file.content_type.startswith('image/'):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File must be an image"
        )

    # Check if image type is supported
    if not is_mime_type_allowed(file.content_type):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Unsupported image format. Supported formats: {', '.join(ALLOWED_MIME_TYPES)}"
        )

    # Check file size by reading chunks without loading the whole file
    size = 0
    # First, move to the beginning
    await file.seek(0)

    chunk = await file.read(CHUNK_SIZE)
    while chunk:
        size += len(chunk)
        if size > max_size:
            # Reset file pointer to beginning
            await file.seek(0)
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Image is too large. Maximum size is {max_size/1024/1024}MB"
            )
        chunk = await file.read(CHUNK_SIZE)

    # Reset file pointer to beginning
    await file.seek(0)

async def read_chunks(file: UploadFile) -> AsyncGenerator[bytes, None]:
    """
    Read a file in chunks.

    Args:
        file: The uploaded file

    Yields:
        Chunks of file data
    """
    await file.seek(0)

    while True:
        chunk = await file.read(CHUNK_SIZE)
        if not chunk:
            break
        yield chunk

async def stream_avif_to_db(
    db_session: AsyncSession,
    file: UploadFile,
    save_chunk_function: callable,
    user_id: int,
    picture_type: str = "profile",
    commit: bool = True
) -> Optional[object]:
    """
    Stream an already AVIF-formatted image file directly to the database in chunks.

    Args:
        db_session: SQLAlchemy async session
        file: The uploaded AVIF file
        save_chunk_function: Function to save chunks (must accept session, chunk, is_first, is_last, user_id, picture_type)
        user_id: User ID
        picture_type: Type of picture
        commit: Whether to commit the transaction

    Returns:
        The result object from the save operation
    """
    # Validate that it's actually an AVIF image
    if file.content_type != 'image/avif':
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File is not in AVIF format"
        )

    # Validate file
    await validate_image(file)

    try:
        result = None
        is_first_chunk = True

        # Try to get file size from content length header
        content_length = None
        try:
            if hasattr(file, 'size'):
                content_length = file.size
            elif hasattr(file, 'headers') and 'content-length' in file.headers:
                content_length = int(file.headers['content-length'])
        except (TypeError, ValueError):
            # If we can't get the size, we'll detect the end by empty chunk
            pass

        # Reset file pointer to beginning
        await file.seek(0)

        # Stream file directly to database in chunks
        total_bytes_read = 0
        async for chunk in read_chunks(file):
            # Update total bytes read
            total_bytes_read += len(chunk)

            # Check if this is the last chunk
            is_last_chunk = False
            if content_length is not None:
                is_last_chunk = total_bytes_read >= content_length
            else:
                # If we don't know the size, we'll need to look ahead
                # to see if there's more data
                next_chunk = await file.read(1)
                if not next_chunk:
                    is_last_chunk = True
                else:
                    # Put the byte back (if possible)
                    await file.seek(total_bytes_read)

            # Save this chunk
            result = await save_chunk_function(
                db_session,
                chunk,
                is_first_chunk,
                is_last_chunk,
                user_id,
                picture_type,
                commit=False  # Don't commit until the last chunk
            )

            is_first_chunk = False

            # If this was the last chunk, break
            if is_last_chunk:
                break

        # Final commit after all chunks are processed
        if commit and result:
            await db_session.commit()

        return result
    except Exception as e:
        if commit:
            await db_session.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error saving image: {str(e)}"
        )

async def convert_to_avif_and_save(
    db_session: AsyncSession,
    file: UploadFile,
    save_chunk_function: callable,
    user_id: int,
    picture_type: str = "profile",
    commit: bool = True,
    quality: int = AVIF_QUALITY
) -> Optional[object]:
    """
    Convert an image to AVIF format, then stream it to the database in chunks.

    Note: For conversion, we unfortunately need to load the whole image into memory first.
    This function minimizes memory usage for the saving part, but conversion itself requires
    the full image data.

    Args:
        db_session: SQLAlchemy async session
        file: The uploaded image file
        save_chunk_function: Function to save chunks
        user_id: User ID
        picture_type: Type of picture
        commit: Whether to commit the transaction
        quality: AVIF quality level (0-100)

    Returns:
        The result object from the save operation
    """
    # If already AVIF, use the direct streaming function
    if file.content_type == 'image/avif':
        return await stream_avif_to_db(
            db_session, file, save_chunk_function, user_id, picture_type, commit
        )

    # Validate file
    await validate_image(file)

    try:
        # Unfortunately, for conversion we need to read the whole file
        # This is a limitation of image processing libraries
        buffer = io.BytesIO()
        async for chunk in read_chunks(file):
            buffer.write(chunk)

        # Reset buffer to beginning
        buffer.seek(0)

        # Run conversion in a thread pool to not block the event loop
        loop = asyncio.get_event_loop()
        avif_data = await loop.run_in_executor(
            None, 
            lambda: _convert_image_to_avif(buffer, quality)
        )

        # Create a BytesIO buffer from the AVIF data to read in chunks
        avif_buffer = io.BytesIO(avif_data)
        result = None
        is_first_chunk = True

        # Stream the converted AVIF data in chunks
        while True:
            chunk = avif_buffer.read(CHUNK_SIZE)
            if not chunk:
                break

            # Check if this is the last chunk
            is_last_chunk = avif_buffer.tell() >= len(avif_data)

            # Save this chunk
            result = await save_chunk_function(
                db_session,
                chunk,
                is_first_chunk,
                is_last_chunk,
                user_id,
                picture_type,
                commit=False  # Don't commit until the last chunk
            )

            is_first_chunk = False

        # Final commit after all chunks are processed
        if commit:
            await db_session.commit()

        return result
    except UnidentifiedImageError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Could not identify image format"
        )
    except Exception as e:
        if commit:
            await db_session.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error processing image: {str(e)}"
        )
    finally:
        if 'buffer' in locals():
            buffer.close()
        if 'avif_buffer' in locals():
            avif_buffer.close()

def _convert_image_to_avif(image_data: BinaryIO, quality: int = AVIF_QUALITY) -> bytes:
    """
    Convert an image to AVIF format.

    Args:
        image_data: Binary data of the image
        quality: AVIF quality (0-100)

    Returns:
        The AVIF image data as bytes
    """
    try:
        with Image.open(image_data) as img:
            # Check dimensions
            width, height = img.size

            # Resize if necessary
            if width > MAX_WIDTH or height > MAX_HEIGHT:
                # Calculate new dimensions while preserving aspect ratio
                ratio = min(MAX_WIDTH / width, MAX_HEIGHT / height)
                new_width = int(width * ratio)
                new_height = int(height * ratio)
                img = img.resize((new_width, new_height), Image.LANCZOS)

            # Check minimum dimensions
            if width < MIN_WIDTH or height < MIN_HEIGHT:
                raise ValueError(f"Image dimensions ({width}x{height}) are below minimum requirements ({MIN_WIDTH}x{MIN_HEIGHT})")

            # Create output buffer
            output = io.BytesIO()

            # Save as AVIF
            img.save(output, format="AVIF", quality=quality)

            # Get bytes
            output.seek(0)
            return output.getvalue()
    finally:
        # Ensure resources are properly cleaned up
        if 'output' in locals():
            output.close()

async def stream_image_from_db(
    conn: Connection,
    user_id: int,
    picture_type: str = "profile"
) -> AsyncGenerator[bytes, None]:
    """
    Stream an image directly from the database in chunks.

    Args:
        conn: AsyncPG connection
        user_id: User ID
        picture_type: Type of picture

    Yields:
        Chunks of image data
    """
    # Query to get the LO OID
    query = """
    SELECT picture_data FROM user_pictures 
    WHERE user_id = $1 AND type = $2
    """

    # First check if the record exists
    record = await conn.fetchrow(query, user_id, picture_type)

    if not record or not record['picture_data']:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Image not found"
        )

    # Stream the binary data in chunks
    image_data = record['picture_data']

    # Process in chunks
    for i in range(0, len(image_data), CHUNK_SIZE):
        yield image_data[i:i + CHUNK_SIZE]

async def get_streaming_response_for_image(
    user_id: int,
    picture_type: str = "profile"
) -> StreamingResponse:
    """
    Create a StreamingResponse for an image.

    Args:
        user_id: User ID
        picture_type: Type of picture

    Returns:
        StreamingResponse with the image
    """
    # Get a connection from the pool
    pool = await init_pg_pool()
    conn = None

    # We'll manage the connection explicitly to avoid leaks
    async def stream_generator():
        nonlocal conn
        try:
            # Acquire connection from pool
            conn = await pool.acquire()

            # Stream the image in chunks
            async for chunk in stream_image_from_db(conn, user_id, picture_type):
                yield chunk

        except Exception as e:
            # Log the error but don't raise - StreamingResponse can't handle exceptions after it starts
            print(f"Error in stream_generator: {e}")

        finally:
            # Always release the connection back to the pool
            if conn:
                await pool.release(conn)
                conn = None

    # Create the response
    response = StreamingResponse(
        stream_generator(),
        media_type="image/avif"
    )

    # Add a callback to ensure connection cleanup if the client disconnects
    # (This is a bit of a hack but necessary for proper cleanup)
    response.background = lambda: asyncio.create_task(ensure_connection_cleanup(conn, pool))

    return response

async def ensure_connection_cleanup(conn, pool):
    """Ensure the connection is released back to the pool"""
    if conn:
        try:
            await pool.release(conn)
        except Exception as e:
            print(f"Error releasing connection: {e}")


## app/core/errors.py
from copy import deepcopy

def create_response_dict(response={},
                        InvalidHeader=True,
                        JWTDecode=True,
                        CSRF=True,
                        MissingToken=True,
                        RevokedToken=True,
                        AccessToken=True,
                        RefreshToken=True,
                        FreshToken=True):
    """
    Used for creating a response dict to be used in the FastAPI router responses parameter for
    documenting the exceptions that can be thrown by the fastapi_another_jwt_auth library

    Args:
    response (dict, optional): Extra to be added to the response dict. Defaults to {}.
    InvalidHeader (bool, optional): Handle InvalidHeaderError. Defaults to True.
    JWTDecode (bool, optional): Handle JWTDecodeError. Defaults to True.
    CSRF (bool, optional): Handle CSRFError(Bad Actor attack). Defaults to True.
    MissingToken (bool, optional): Handle MissingTokenError. Defaults to True.
    RevokedToken (bool, optional): Handle RevokedTokenError. Defaults to True.
    AccessToken (bool, optional): Handle AccessTokenRequired. Defaults to True.
    RefreshToken (bool, optional): Handle RefreshTokenRequired. Defaults to True.
    FreshToken (bool, optional): Handle FreshTokenRequired. Defaults to True.
    """
    new_response = deepcopy(response)
    if InvalidHeader or CSRF or MissingToken:
        new_response[400] = {"description": "Invalid credentials (CSRF, Invalid Header, Missing Token)"}
    if JWTDecode or RevokedToken:
        new_response[401] = {"description": "Token expired or revoked get a new one"}
    if AccessToken or RefreshToken or FreshToken:
        new_response[403] = {"description": "Access denied (Access token , Fresh token (created by login not refresh), Refresh token required)"}

    new_response[500] = {"description": "Internal server error abnormal behavior"}
    return new_response


## app/core/__init__.py
from .security import *
from .application import server, AddRouter
from .config import *
from .errors import *
from .picture_config import *

# from .cors import * # should not be needed anywhere else except in this module

## app/core/config.py
from pathlib import Path
from typing import Any, Dict, List
from os import getenv
import re

from yaml import safe_load, YAMLError

from ..utils.patterns import singleton

class Config:
    """Singleton class that loads and stores configuration files as dictionaries."""

    _config_data: Dict[str, Dict[str, Any]] = {}  # Stores loaded YAML configs
    __default_config_file__ = "./config/config.yaml"  # Default config file

    @classmethod
    def load_config(cls, file_path: str) -> Dict[str, Any]:
        """
        Loads a YAML configuration file and stores it in the class dictionary.

        Args:
            file_path (str): Path to the YAML configuration file.

        Returns:
            Dict[str, Any]: Parsed YAML content.

        Raises:
            FileNotFoundError: If the file doesn't exist.
            ValueError: If the YAML content is invalid.
        """
        file_path = str(Path(file_path).resolve())  # Normalize path
        if file_path in cls._config_data:
            return cls._config_data[file_path]  # Return cached config

        if not Path(file_path).exists():
            raise FileNotFoundError(f"Config file not found: {file_path}")

        try:
            with open(file_path, "r", encoding="utf-8") as file:
                yaml_content = safe_load(file) or {}
                cls._eval_expressions(yaml_content)  # Evaluate expressions
                cls._convert_time_units(yaml_content)  # Convert time units
                cls._config_data[file_path] = yaml_content  # Cache config
                return yaml_content
        except YAMLError as e:
            raise ValueError(f"Invalid YAML format in {file_path}: {e}")

    @classmethod
    def get_property(cls, file_path: str | None, section: str, keys: List[str] = None) -> Dict[str, Any]:
        """
        Retrieves specific configuration properties from a loaded YAML file.

        Args:
            file_path (str): Path to the YAML configuration file.
            section (str): The top-level section in the YAML file.
            keys (List[str], optional): A list of specific sub-properties to retrieve.

        Returns:
            Dict[str, Any]: The requested config values.

        Raises:
            KeyError: If the section or keys do not exist.
        """
        if not file_path:
            file_path = cls.__default_config_file__  # Use default config file if not provided
        config = cls.load_config(file_path)  # Load config if not already loaded
        section_data = config.get(section, {})

        if keys:
            result = {}
            for key in keys:
                if key in section_data:
                    result[key] = section_data[key]
                else:
                    raise KeyError(f"Key '{key}' not found in section '{section}'")
            return result
        return section_data  # Return the entire section if no keys provided

    @staticmethod
    def _eval_expressions(config: Dict[str, Any]):
        """
        Evaluate expressions in string values, e.g., "5 * 1024 * 1024"

        Args:
            config (Dict[str, Any]): Configuration dictionary
        """
        # Pattern for simple arithmetic expressions (digits, operators +, -, *, /, and whitespace)
        expr_pattern = re.compile(r'^\s*\d+(\s*[\+\-\*\/]\s*\d+)+\s*$')

        def process_value(value):
            if isinstance(value, str) and expr_pattern.match(value):
                try:
                    # Evaluate simple arithmetic expression
                    return eval(value, {"__builtins__": {}}, {})
                except:
                    # If evaluation fails, return the original string
                    return value
            return value

        def traverse_and_eval(d: Dict[str, Any]):
            """Recursively traverse dictionary and evaluate expressions."""
            for key, value in list(d.items()):  # Create a list to avoid dict size change during iteration
                if isinstance(value, dict):
                    traverse_and_eval(value)
                elif isinstance(value, list):
                    d[key] = [process_value(item) if not isinstance(item, dict) else traverse_and_eval(item) 
                             for item in value]
                else:
                    d[key] = process_value(value)
            return d

        traverse_and_eval(config)

    @staticmethod
    def _convert_time_units(config: Dict[str, Any]):
        """
        Converts time-related fields in the config to seconds.

        Args:
            config (Dict[str, Any]): Configuration dictionary.
        """
        time_units = {"seconds": 1, "minutes": 60, "hours": 3600, "days": 86400, "months": 2592000}

        def convert_time(value):
            if isinstance(value, dict):
                total_seconds = sum(time_units.get(unit, 0) * count for unit, count in value.items() if unit in time_units)
                return total_seconds if total_seconds > 0 else value  # If no valid time keys, return original
            return value

        def traverse_and_convert(d: Dict[str, Any]):
            """Recursively traverse the dictionary and convert time fields."""
            for key, value in d.items():
                if isinstance(value, dict):
                    d[key] = convert_time(value)  # Convert time-related fields
                    traverse_and_convert(value)  # Recurse deeper

        traverse_and_convert(config)

## app/core/picture_config.py
"""
Configuration module for image handling.
"""
from typing import Dict, List, Any, Set
from pydantic import BaseModel

from .config import Config

class PictureConfig(BaseModel):
    """Image handling configuration"""
    max_size: int
    chunk_size: int
    max_width: int
    max_height: int
    min_width: int
    min_height: int
    allowed_types: List[str]
    avif_quality: int = 70  # Default value if not specified in config

    @classmethod
    def from_config(cls) -> 'PictureConfig':
        """
        Load picture configuration from the config file.

        Returns:
            PictureConfig: Configuration for image handling
        """
        # Load from config file
        try:
            config = Config.get_property(None, "picture", [
                "max_size", "chunk_size", "max_width", "max_height", 
                "min_width", "min_height", "allowed_types", "avif_quality"
            ])
        except KeyError:
            # Fallback to defaults if some keys are missing
            config = Config.get_property(None, "picture", [])

        # Default values
        defaults = {
            "max_size": 5 * 1024 * 1024,  # 5MB
            "chunk_size": 512 * 1024,  # 512KB
            "max_width": 1920,
            "max_height": 1080,
            "min_width": 100,
            "min_height": 100,
            "allowed_types": ["image/jpeg", "image/png", "image/avif", "image/webp"],
            "avif_quality": 70
        }

        # Merge config with defaults
        merged_config = {**defaults, **config}

        return cls(**merged_config)

# Global instance
picture_config = PictureConfig.from_config()

# MIME type mapping
MIME_TYPE_TO_PIL_FORMAT = {
    "image/jpeg": "JPEG",
    "image/png": "PNG",
    "image/webp": "WEBP",
    "image/avif": "AVIF",
}

def get_allowed_mime_types() -> Set[str]:
    """
    Get the set of allowed MIME types.

    Returns:
        Set[str]: Allowed MIME types
    """
    return set(picture_config.allowed_types)

def is_mime_type_allowed(mime_type: str) -> bool:
    """
    Check if a MIME type is allowed.

    Args:
        mime_type: MIME type to check

    Returns:
        bool: True if allowed, False otherwise
    """
    return mime_type in get_allowed_mime_types()

def get_pil_format(mime_type: str) -> str:
    """
    Get the PIL format for a MIME type.

    Args:
        mime_type: MIME type

    Returns:
        str: PIL format

    Raises:
        ValueError: If the MIME type is not supported
    """
    if mime_type not in MIME_TYPE_TO_PIL_FORMAT:
        raise ValueError(f"Unsupported MIME type: {mime_type}")

    return MIME_TYPE_TO_PIL_FORMAT[mime_type]

## app/core/application.py
from os import getenv
import atexit
from contextlib import asynccontextmanager
from typing import Callable

from dotenv import load_dotenv
from fastapi import FastAPI, Depends
from fastapi.openapi.utils import get_openapi
from apscheduler.schedulers.asyncio import AsyncIOScheduler

load_dotenv()

from ..utils.patterns import singleton
from ..db.postgress.engine import postgress
from ..services.scheduler.factory import CronJobFactory
from ..services.auth.roles import init_roles
from ..services.content.terms import init_terms
from .cors.config import init_cors
from .security.decorators import SecurityRequirement

@singleton
class Server:
    def AddCronJob(self, func: Callable, **kwargs: dict):
        """ Add a cron job to the scheduler """
        self.scheduler.add_job(self.run_job_with_session, args=[func], **kwargs)

    def __init__(self):
        # First, initialize your properties
        self.port = int(getenv("PORT", 5000))
        self.host = '0.0.0.0'
        self.log_lvl = "info"
        self.postgress = postgress
        # Initialize scheduler before setting up lifespan so we dont get stupid errors
        self.scheduler = AsyncIOScheduler()

        # Acording the fast api docs this better than using on_event(deprecated)
        # I disagree but need to make the code compatible with the rest of the code
        @asynccontextmanager
        async def lifespan(app: FastAPI):
            CronJobFactory.set_add_cron_job(self.AddCronJob)

            # Check if tables exist and initialize data if needed
            exists, _ = await self.postgress.check_all_models_exist()
            if not exists:
                await self.postgress.create_all()
                await self.init_roles()
                await init_terms()

            # Initialize the AsyncPG connection pool
            from ..db.postgress.postgress_pool import init_pg_pool
            print("Initializing PostgreSQL connection pool...")
            await init_pg_pool()

            # Start scheduler
            self.scheduler.start()
            CronJobFactory.register_jobs()

            yield  # This is where FastAPI serves requests

            # Shutdown
            try:
                if self.scheduler and hasattr(self.scheduler, 'running') and self.scheduler.running:
                    print("Shutting down scheduler...")
                    self.scheduler.shutdown(wait=False)
            except Exception as e:
                print(f"Error shutting down scheduler: {e}")

            try:
                # Close AsyncPG connection pool
                from ..db.postgress.postgress_pool import close_pg_pool
                print("Closing PostgreSQL connection pool...")
                await close_pg_pool()
            except Exception as e:
                print(f"Error closing PostgreSQL connection pool: {e}")

            try:
                if self.postgress:
                    print("Closing database connections...")
                    await self.postgress.close()
            except Exception as e:
                print(f"Error closing database connections: {e}")

        self.app = FastAPI(
            title="Autrement Capable API Dev Server",
            description="The API for Autrement Capable Backend.",
            version=getenv("VERSION", "0.1.0alpha"),
            docs_url="/docs" if getenv("MODE") == "DEV" else None,
            redoc_url="/redoc" if getenv("MODE") == "DEV" else None,
            lifespan=lifespan,
        )

        # Initialize CORS
        init_cors(self.app)

        # Set up custom OpenAPI
        self.app.openapi = self.__custom_openapi__

    async def on_startup(self):
        """ This function runs during startup of FastAPI application. """
        # Initialize the database and create tables asynchronously
        exists, _ = await self.postgress.check_all_models_exist()
        if not exists: # if tables do not exist, create them and init data
            await self.postgress.create_all()

            # Initialize roles asynchronously
            await self.init_roles()

            # Initialize Terms creation
            await init_terms()

        server.scheduler.start()
        CronJobFactory.register_jobs()

    @staticmethod
    async def run_job_with_session(func:Callable):
        """Executes a cron job with a managed AsyncSession."""
        async with postgress.Session() as session:
            try:
                await func(session)
            except Exception as e:
                print(f"[TaskScheduler] Error running {func.__name__}: {e}")
                await session.rollback()
            finally:
                await session.close()

    async def init_roles(self):
        """ Initialize roles asynchronously """
        session = await self.postgress.getSession()
        await init_roles(session)

    def __custom_openapi__(self):
        """
        Custom OpenAPI schema for FastAPI app.
        """
        if self.app.openapi_schema:
            return self.app.openapi_schema

        openapi_schema = get_openapi(
            title="Autrement Capable API Dev Server",
            version=getenv("VERSION", "0.1.0alpha"),
            description="The API for Autrement Capable Backend.",
            routes=self.app.routes,
        )

        # Define security schemes
        openapi_schema["components"]["securitySchemes"] = {
            "Authorization": {
                "type": "http",
                "scheme": "bearer",
                "bearerFormat": "JWT",
                "description": "JWT Authorization header using the Bearer scheme"
            },
            "RefreshCookie": {
                "type": "apiKey",
                "in": "cookie",
                "name": "refresh_token",
                "description": "JWT Refresh token stored in HTTP-only cookie"
            }
        }

        # Add security requirements to endpoints based on their decorators
        for path, path_item in openapi_schema["paths"].items():
            for method, operation in path_item.items():
                for route in self.app.routes:
                    if hasattr(route, "endpoint") and route.path == path and method.upper() in route.methods:
                        endpoint = route.endpoint

                        # Find the original function if wrapped
                        while hasattr(endpoint, "__wrapped__"):
                            endpoint = endpoint.__wrapped__

                        if hasattr(endpoint, "requires_auth") and endpoint.requires_auth:
                            security_type = getattr(endpoint, "security_type", SecurityRequirement.ACCESS_TOKEN)

                            if security_type == SecurityRequirement.ACCESS_TOKEN:
                                operation["security"] = [{"Authorization": []}]
                            elif security_type == SecurityRequirement.REFRESH_COOKIE:
                                operation["security"] = [{"RefreshCookie": []}]
                            elif security_type == SecurityRequirement.BOTH_TOKENS:
                                operation["security"] = [{"Authorization": [], "RefreshCookie": []}]
                            else:
                                operation["security"] = [{"Authorization": []}]

                            # Add custom description if provided
                            custom_desc = getattr(endpoint, "security_description", None)
                            if custom_desc:
                                if "description" not in operation:
                                    operation["description"] = ""
                                operation["description"] += f"\n\n**Auth:** {custom_desc}"

        self.app.openapi_schema = openapi_schema
        return self.app.openapi_schema

server = Server()

def AddRouter(router):
    server.app.include_router(router)

__all__ = ["server", "AddRouter"]


## app/core/security/token_creation.py
import os
import jwt
import datetime
import base64
from uuid import uuid4
from typing import Union, Optional, Dict, Any

from fastapi import HTTPException, status, Depends, Request, Response, Cookie
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from cryptography.hazmat.primitives.ciphers.aead import AESGCM

from .config import settings as S
from ...db.postgress.engine import getSession
from ...db.postgress.models import RevokedToken

# not 100% sure if this shulbe here or in database.postgress.actions.revoked_jwt_tokens
async def is_token_revoked(session: AsyncSession, jti: str) -> bool:
    """ Check if a token is in the revoked token list
    Args:
    session (AsyncSession): The SQLAlchemy session
    jti (str): The JWT ID of the token

    Returns:
    bool: True if the token is revoked, False otherwise"""
    from ...db.postgress.repositories.revoked_jwt_tokens import get_revoked_token_by_jti

    result = await get_revoked_token_by_jti(session, jti)
    return result is not None

def extract_token_from_header(request: Request) -> str:
    """ Extract JWT token from Authorization header

    Args:
        request (Request): The FastAPI request object

    Returns:
        str: The JWT token
    """
    try:
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith(S.auth_schema):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or missing Authorization header.")
        return auth_header.split(" ")[1]
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Error extracting token from header.")

def encrypt_payload(payload: dict) -> bytes:
    """ Encrypt JWT payload using AES-GCM

    Args:
        payload (dict): The JWT payload to be encrypted

    Returns:
        bytes: The nonce and encrypted payload into a single byte string
    """
    aesgcm = AESGCM(S.aes_key)
    nonce = os.urandom(S.nonce_size)  # Generate a unique nonce per encryption
    data = jwt.encode(payload, S.authjwt_secret_key, algorithm=S.authjwt_algorithm).encode()
    encrypted = aesgcm.encrypt(nonce, data, None)
    return nonce + encrypted

def decrypt_payload(encrypted_payload: bytes) -> dict:
    """ Decrypt JWT payload using AES-GCM

    Args:
        encrypted_payload (bytes): The encrypted payload(must include nonce)

    Returns:
        dict: The decrypted payload
    """

    try:
        aesgcm = AESGCM(S.aes_key)
        nonce = encrypted_payload[:S.nonce_size]
        data = encrypted_payload[S.nonce_size:]
        decrypted = aesgcm.decrypt(nonce, data, None).decode()
        payload = jwt.decode(decrypted, S.authjwt_secret_key, algorithms=[S.authjwt_algorithm])
        # because there is some standart i need to follow sub must be str so i convert it back to int
        payload["sub"] = int(payload["sub"])
        return payload
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Error decrypting token.")

def create_token(user_id: int, role_id: int, refresh: bool = False, fresh: bool = False) -> str:
    """ Create a JWT (access or refresh) token for the user

    Args:
    user_id (int): The user ID
    role_id (int): The role ID (used for role-based access control)
    refresh (bool): If creating an access token, set to False. If creating a refresh token, set to True. Defaults to False.
    fresh (bool): True if the token is fresh, defaults to False

    Returns:
    str: The JWT token(payload contains the token type and the encrypted data)

    Note:
    **Payload Schema**:
    ```json
    {
        "refresh": bool, //True if refresh token, False if access token
        "payload": bytes
    }
    ```
    """
    # Set the expiration time based on token type
    expires_delta = datetime.timedelta(seconds=S.jwt_refresh_token_expires if refresh else S.jwt_access_token_expires)

    payload = {
        "sub": str(user_id),
        "role": role_id,
        "iat": datetime.datetime.utcnow(),
        "exp": datetime.datetime.utcnow() + expires_delta,
        "fresh": fresh,
        "jti": base64.urlsafe_b64encode(uuid4().bytes).decode().rstrip("=")
    }
    encrypted_data = encrypt_payload(payload)
    jwt_payload = {"refresh": refresh, "payload": encrypted_data.hex()}  # Store encrypted data as hex
    return jwt.encode(jwt_payload, S.authjwt_secret_key, algorithm=S.authjwt_algorithm)

def set_refresh_cookie(response: Response, refresh_token: str):
    """
    Set refresh token in an HTTP-only secure cookie

    Args:
        response (Response): FastAPI response object
        refresh_token (str): The refresh token to store
    """
    cookie_settings = {
        "key": "refresh_token",
        "value": refresh_token,
        "httponly": True,
        "secure": S.cookie_secure,  # True in production, can be False in development
        "samesite": "lax",  # Helps prevent CSRF
        "max_age": S.jwt_refresh_token_expires,
        "path": "/auth"  # Limit cookie to auth routes only
    }
    response.set_cookie(**cookie_settings)

def clear_refresh_cookie(response: Response):
    """
    Clear the refresh token cookie

    Args:
        response (Response): FastAPI response object
    """
    response.delete_cookie(key="refresh_token", path="/auth")

    # Also clear from root path to be thorough
    response.delete_cookie(
        key="refresh_token",
        path="/",
        secure=True,
        httponly=True,
        samesite="lax"
    )

async def decode_token(session: AsyncSession, token_source: Union[Request, str], is_refresh: bool = False, required_fresh: bool = False) -> dict:
    """ Extract, decode, and verify JWT token from request header or JWT string

    Args:
    session (AsyncSession): The SQLAlchemy session
    token_source (Request | JWT (str)): The FastAPI request object | The JWT token string
    is_refresh (bool): True if decoding a refresh token, False if decoding an access token, defaults to False
    required_fresh (bool): True if the token must be fresh, defaults to False

    Returns:
    dict: The decoded payload

    Raises:
    - If the token is invalid, expired, or revoked, an HTTPException is raised
    - If the token is not fresh, an HTTPException is raised if required_fresh is True

    Note:
    **Decrypted Payload Schema**:
    ```json
    {
        "sub": int, // The user ID
        "role": int, // The role ID
        "iat": datetime, // The issued at time
        "exp": datetime, // The expiration time
        "fresh": bool, // True if the token is fresh
        "jti": str // The JWT ID
    }
        ```
    """
    if isinstance(token_source, str):
        token = token_source
    else:
        token = extract_token_from_header(token_source)
    try:
        payload = jwt.decode(token, S.authjwt_secret_key, algorithms=[S.authjwt_algorithm])
        if "refresh" not in payload or "payload" not in payload:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token format.")

        if payload["refresh"] != is_refresh:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token type.")

        decrypted_payload = decrypt_payload(bytes.fromhex(payload["payload"]))

        if required_fresh and not decrypted_payload.get("fresh", False):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token is not fresh.")

        if await is_token_revoked(session, decrypted_payload["jti"]):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token has been revoked.")

        return decrypted_payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token has expired.")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token.")
    except HTTPException:
        raise # Re-raise HTTPException
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Error decoding token.")

# HTTP bearer scheme for access token extraction
http_bearer = HTTPBearer(auto_error=False)

import warnings

class JWTBearer:
    """DEPRECATED: This class is deprecated and will be removed in future versions.

    Please use the `secured_endpoint` decorator instead:
    ```python
    from app.core.security.decorators import secured_endpoint

    @router.get("/protected-route")
    @secured_endpoint()  # Use parameters like secured_endpoint(fresh=True) if needed
    async def protected_endpoint(jwt, session): # jwt and session are auto-injected
        # jwtP["sub"] is the user ID
        # jwtP["role"] is the role ID
        return {"message": "Success"}
    ```
    """

    def __init__(self, is_refresh: bool = False, required_fresh: bool = False):
        """
        Args:
            is_refresh (bool): If True, requires a refresh token instead of an access token.
            required_fresh (bool): If True, ensures the token is fresh.
        """
        warnings.warn(
            "JWTBearer is deprecated. Use secured_endpoint instead.",
            DeprecationWarning,
            stacklevel=2
        )
        self.is_refresh = is_refresh
        self.required_fresh = required_fresh
        self._payload = None  # Stores decoded JWT payload

    async def __call__(
        self, 
        request: Request, 
        response: Response = None,
        credentials: Optional[HTTPAuthorizationCredentials] = Depends(http_bearer),
        refresh_token: Optional[str] = Cookie(None, alias="refresh_token"),
        session: AsyncSession = Depends(getSession)
    ):
        """
        Extract, decode, and validate JWT token from either header (access token) or cookie (refresh token).

        Args:
            request (Request): Auto-injected FastAPI request object.
            response (Response, optional): Auto-injected FastAPI response object.
            credentials (HTTPAuthorizationCredentials, optional): Access token extracted from header.
            refresh_token (str, optional): Refresh token extracted from cookie.
            session (AsyncSession): Auto-injected SQLAlchemy session.

        Returns:
            dict: The decoded JWT payload and a boolean indicating if the token is a refresh token.

        Raises:
            HTTPException: If the token is invalid, expired, revoked, or does not meet requirements.
        """
        if self.is_refresh:
            # For refresh tokens, check the cookie
            if not refresh_token:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED, 
                    detail="Refresh token missing. Please login again."
                )
            token = refresh_token
            # Decode directly from the string
            self._payload = await decode_token(
                session, token, is_refresh=True, required_fresh=self.required_fresh
            )
        else:
            # For access tokens, check the Authorization header
            if not credentials:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED, 
                    detail="Access token missing. Please login again."
                )
            # Decode from the header
            self._payload = await decode_token(
                session, credentials.credentials, is_refresh=False, required_fresh=self.required_fresh
            )

        return {"payload": self._payload, "refresh": self.is_refresh}

## app/core/security/__init__.py
from .config import *
from .decorators import *
from .token_creation import *

## app/core/security/config.py
import os
import base64
from os import getenv, urandom

import yaml
from pydantic import BaseModel
from dotenv import load_dotenv

from ...utils.config_helpers import get_property

load_dotenv()

__config_file__ = "./config/config.yaml"

class Settings(BaseModel):
    authjwt_secret_key: str
    jwt_access_token_expires: int
    jwt_refresh_token_expires: int
    authjwt_algorithm: str
    authjwt_token_location: list[str]
    authjwt_denylist_enabled: bool
    authjwt_denylist_token_checks: list[str]
    aes_key: bytes
    nonce_size: int
    auth_schema: str
    cookie_secure: bool  # Whether to use secure cookies (HTTPS only)

    @classmethod
    def from_yaml(cls, config_path: str):
        with open(config_path, "r") as file:
            config = yaml.safe_load(file)

        config_vals = get_property(config, "auth", ["access_token_duration", "refresh_token_duration"])

        # Determine if we're in production or development
        is_prod = getenv("MODE", "DEV").upper() != "DEV"

        return cls(
            authjwt_secret_key=getenv("SERVER_SECRET", "default_secret"),
            jwt_access_token_expires=config_vals.get("access_token_duration", 3600),
            jwt_refresh_token_expires=config_vals.get("refresh_token_duration", 86400),
            authjwt_algorithm="HS256",
            authjwt_token_location=["headers", "cookies"],  # Now supporting both headers and cookies
            authjwt_denylist_enabled=True,
            authjwt_denylist_token_checks=["access", "refresh"],
            aes_key=base64.b64decode(getenv("AES_KEY", base64.b64encode(urandom(32)).decode('utf-8'))),
            nonce_size=12,
            auth_schema="Bearer ",
            cookie_secure=is_prod  # Secure cookies in production, non-secure in development
        )

# Load settings from the YAML file during class initialization
__config_file__ = "./config/config.yaml"
settings = Settings.from_yaml(__config_file__)

## app/core/security/decorators.py
## core/security/decorators.py
from functools import wraps
from enum import Enum, auto
from typing import List, Optional, Callable, Dict, Any, TypeVar, Awaitable
import inspect
from inspect import Parameter, Signature

from fastapi import Request, Response, HTTPException, status, Depends
from sqlalchemy.ext.asyncio import AsyncSession

from .token_creation import decode_token
from ...db.postgress.engine import getSession

class SecurityRequirement(Enum):
    ACCESS_TOKEN = auto()      # Bearer token in Authorization header
    REFRESH_COOKIE = auto()    # Refresh token in HTTP-only cookie
    BOTH_TOKENS = auto()       # Requires both access token and refresh cookie

def extract_token_from_header(request: Request) -> str:
    """Extract JWT token from Authorization header"""
    auth_header = request.headers.get("Authorization")
    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, 
            detail="Invalid or missing Authorization header."
        )
    return auth_header.split(" ")[1]

# Define a dependency for getting JWT data
async def get_jwt_data(
    request: Request,
    security_type: SecurityRequirement = SecurityRequirement.ACCESS_TOKEN,
    session: AsyncSession = Depends(getSession)
):
    """Get JWT data based on security requirements"""
    # Handle different token requirements
    access_payload = None
    refresh_payload = None

    # Get access token if needed
    if security_type in [SecurityRequirement.ACCESS_TOKEN, SecurityRequirement.BOTH_TOKENS]:
        try:
            token = extract_token_from_header(request)
            access_payload = await decode_token(session, token, is_refresh=False)
        except HTTPException as e:
            if security_type == SecurityRequirement.ACCESS_TOKEN:
                raise  # Re-raise if access token is required

    # Get refresh token if needed
    if security_type in [SecurityRequirement.REFRESH_COOKIE, SecurityRequirement.BOTH_TOKENS]:
        refresh_token = request.cookies.get("refresh_token")
        if not refresh_token:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Refresh token missing"
            )
        try:
            refresh_payload = await decode_token(session, refresh_token, is_refresh=True)
        except HTTPException:
            raise  # Always re-raise for refresh token

    # Make sure we have all required tokens
    if security_type == SecurityRequirement.BOTH_TOKENS and (not access_payload or not refresh_payload):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Both access and refresh tokens are required"
        )

    # Return payload directly for simpler access
    if security_type == SecurityRequirement.ACCESS_TOKEN:
        return access_payload  # Return payload directly
    elif security_type == SecurityRequirement.REFRESH_COOKIE:
        return refresh_payload  # Return payload directly
    else:  # BOTH_TOKENS
        # For both tokens, we need to return both payloads
        # but we'll handle this differently in the decorator
        return {"access": access_payload, "refresh": refresh_payload}

def secured_endpoint(security_type: SecurityRequirement = SecurityRequirement.ACCESS_TOKEN, description: Optional[str] = None):
    """
    Decorator that adds JWT authentication to an endpoint.

    This decorator injects JWT data directly into the function parameters:
    - For ACCESS_TOKEN: jwt parameter contains the access token payload
    - For REFRESH_COOKIE: jwt parameter contains the refresh token payload
    - For BOTH_TOKENS: jwt parameter contains access payload, refresh_jwt contains refresh payload

    Args:
        security_type: Type of security requirements
        description: Optional custom description for the security requirement

    Returns:
        A decorator that wraps the endpoint function and properly injects JWT data.
    """
    def decorator(func: Callable):
        # Store security requirements on the function for OpenAPI docs
        func.requires_auth = True
        func.security_type = security_type
        func.security_description = description

        # Get the original function signature
        sig = inspect.signature(func)

        # Create a helper function for dependency injection
        async def jwt_dependency(
            request: Request,
            session: AsyncSession = Depends(getSession)
        ) -> Dict[str, Any]:
            return await get_jwt_data(request, security_type, session)

        # Create a new parameter list with JWT dependency properly injected
        new_params = []

        for name, param in sig.parameters.items():
            if name == "jwt":
                # Replace jwt parameter with our dependency
                new_param = Parameter(
                    name="jwt",
                    kind=param.kind,
                    annotation=dict,
                    default=Depends(jwt_dependency)
                )
                new_params.append(new_param)
            elif name == "refresh_jwt" and security_type == SecurityRequirement.BOTH_TOKENS:
                # For refresh_jwt, we'll inject it in the wrapper
                continue
            else:
                new_params.append(param)

        # Create a new signature with the modified parameters
        new_sig = sig.replace(parameters=new_params)

        # Create a wrapper function
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Handle BOTH_TOKENS case
            if security_type == SecurityRequirement.BOTH_TOKENS and 'jwt' in kwargs:
                combined_data = kwargs['jwt']
                # Split the combined data into separate parameters
                kwargs['jwt'] = combined_data['access']
                if 'refresh_jwt' in sig.parameters:
                    kwargs['refresh_jwt'] = combined_data['refresh']

            return await func(*args, **kwargs)

        # Apply the new signature to our wrapper
        wrapper.__signature__ = new_sig

        return wrapper
    return decorator

## app/core/cors/__init__.py
from .config import *

## app/core/cors/config.py
## core/cors/config.py
from fastapi.middleware.cors import CORSMiddleware
import logging

logger = logging.getLogger(__name__)

def init_cors(app):
    # Log that we're initializing CORS
    logger.info("Initializing CORS middleware")
    
    origins = [
        "http://localhost:8080",
        "http://localhost:8081",
        "https://localhost:8080",
        "https://localhost:8081",
        "http://localhost:5000",
        "https://localhost:5000",
        "http://localhost:3000",
        "https://localhost:3000",
        # Add your frontend origin here
        "http://127.0.0.1:8080",
        "http://127.0.0.1:8081",
        "http://127.0.0.1:5000",
        "http://127.0.0.1:3000",
        "https://api.autrement-cap.fr",
        "https://pgadmin.autrement-cap.fr",
    ]
    
    # Log the allowed origins
    logger.info(f"CORS allowed origins: {origins}")
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_origin_regex=r"https?://(localhost|127\.0\.0\.1)(:[0-9]+)?",  # Allow any localhost port
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
        expose_headers=["Content-Type", "Content-Disposition"],
        max_age=600,  # Cache preflight requests for 10 minutes
    )
    
    # Add a middleware for debugging CORS issues
    @app.middleware("http")
    async def debug_cors(request, call_next):
        logger.debug(f"Incoming request: {request.method} {request.url}")
        logger.debug(f"Headers: {request.headers}")
        
        # Process the request
        response = await call_next(request)
        
        # Log the response status
        logger.debug(f"Response status: {response.status_code}")
        logger.debug(f"Response headers: {response.headers}")
        
        return response
    
    logger.info("CORS middleware initialized")


## app/db/__init__.py
# blank init file

## app/db/postgress/__init__.py
from .models import *
from .repositories import *
from .engine import *

## app/db/postgress/postgress_pool.py
"""
Core PostgreSQL connection pool manager.
"""
from typing import Optional, Dict, Any, AsyncGenerator
import asyncpg
from asyncpg.pool import Pool
from os import getenv

from ...core.config import Config

# Cache the connection pool
_pg_pool: Optional[Pool] = None
_pg_config: Optional[Dict[str, Any]] = None

def get_pool_config() -> Dict[str, Any]:
    """
    Get PostgreSQL pool configuration from environment variables and config file.

    Returns:
        Dict[str, Any]: Pool configuration
    """
    global _pg_config

    if _pg_config is None:
        # Get config from file
        config = Config.get_property(None, "database", ["connection_pool"])
        pool_config = config.get("connection_pool", {})

        # Default values
        _pg_config = {
            "min_size": pool_config.get("min_size", 2),
            "max_size": pool_config.get("max_size", 10),
            "max_queries": pool_config.get("max_queries", 50000),
            "max_inactive_connection_lifetime": pool_config.get("max_inactive_connection_lifetime", 300),
            "timeout": pool_config.get("timeout", 60),
            "command_timeout": pool_config.get("command_timeout", 60),
            "statement_cache_size": pool_config.get("statement_cache_size", 100),
        }

    return _pg_config

def get_connection_string() -> str:
    """
    Get PostgreSQL connection string from environment variables.

    Returns:
        str: Connection string
    """
    return (
        f"postgresql://{getenv('POSTGRES_USER')}:{getenv('POSTGRES_PASSWORD')}"
        f"@{getenv('POSTGRES_SERVER')}:{getenv('POSTGRES_PORT')}/{getenv('POSTGRES_DB')}"
    )

async def init_pg_pool() -> Pool:
    """
    Initialize the PostgreSQL connection pool.

    Returns:
        Pool: AsyncPG connection pool
    """
    global _pg_pool

    if _pg_pool is None:
        # Get connection string and pool config
        pg_conn_string = get_connection_string()
        pool_config = get_pool_config()

        # Create pool
        print(f"Initializing PostgreSQL connection pool (max_size: {pool_config['max_size']})")
        _pg_pool = await asyncpg.create_pool(
            pg_conn_string,
            min_size=pool_config["min_size"],
            max_size=pool_config["max_size"],
            max_queries=pool_config["max_queries"],
            max_inactive_connection_lifetime=pool_config["max_inactive_connection_lifetime"],
            timeout=pool_config["timeout"],
            command_timeout=pool_config["command_timeout"],
            statement_cache_size=pool_config["statement_cache_size"],
        )

    return _pg_pool

async def close_pg_pool() -> None:
    """Close the PostgreSQL connection pool."""
    global _pg_pool

    if _pg_pool is not None:
        print("Closing PostgreSQL connection pool")
        await _pg_pool.close()
        _pg_pool = None

async def get_pg_connection() -> AsyncGenerator[asyncpg.Connection, None]:
    """
    Get a PostgreSQL connection from the pool.

    Yields:
        Connection: AsyncPG connection
    """
    pool = await init_pg_pool()

    async with pool.acquire() as conn:
        yield conn


## app/db/postgress/engine.py
from os import getenv

from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker, declarative_base, Session
from sqlalchemy import create_engine, inspect

from ...utils.patterns import singleton

DATABASE_URL_ASYNC = (
    f"postgresql+asyncpg://{getenv('POSTGRES_USER')}:{getenv('POSTGRES_PASSWORD')}"
    f"@{getenv('POSTGRES_SERVER')}:{getenv('POSTGRES_PORT')}/{getenv('POSTGRES_DB')}"
)

# Use `psycopg2` for the sync engine
DATABASE_URL_SYNC = (
    f"postgresql+psycopg2://{getenv('POSTGRES_USER')}:{getenv('POSTGRES_PASSWORD')}"
    f"@{getenv('POSTGRES_SERVER')}:{getenv('POSTGRES_PORT')}/{getenv('POSTGRES_DB')}"
)

@singleton
class Postgress:
    def __init__(self):
        self.engine = create_async_engine(DATABASE_URL_ASYNC, echo=True if getenv("MODE") == "DEV" else False, future=True)
        self.sync_engine = create_engine(DATABASE_URL_SYNC, echo=True if getenv("MODE") == "DEV" else False, future=True)

        self.Session = sessionmaker(self.engine, class_=AsyncSession, expire_on_commit=False)
        self.SyncSession = sessionmaker(self.sync_engine, expire_on_commit=False)

        self.Base = declarative_base()

    def get_SyncSession(self) -> Session:
        return self.SyncSession()

    async def close(self):
        """Close all database connections."""
        # Close the async engine
        if self.engine is not None:
            await self.engine.dispose()

        # Close the sync engine (without await since it's not async)
        if hasattr(self, 'sync_engine') and self.sync_engine is not None:
            self.sync_engine.dispose()

    async def create_all(self):
        async with self.engine.begin() as conn:
            await conn.run_sync(self.Base.metadata.create_all)

    async def getSession(self) -> AsyncSession:
        return self.Session()

    async def check_all_models_exist(self) -> tuple[bool, dict]:
        """
        Check if all models exist in the database.

        Use 
        Returns:
            - A tuple containing a boolean indicating if all models exist,
              and a dictionary with table names as keys and their existence as values.
        """
        result = {}
        defined_tables = self.Base.metadata.tables.keys()

        async with self.engine.begin() as conn:
            insp = await conn.run_sync(inspect)
            existing_tables = await conn.run_sync(lambda sync_conn: insp.get_table_names())

            for table in defined_tables:
                result[table] = table in existing_tables

        # if all tables exist, return True, dict otherwise return False, dict
        return all(result.values()), result

postgress = Postgress()

async def getSession() -> AsyncSession:
    return await postgress.getSession()

# async def getSession() -> AsyncSession:
#     async with postgress.Session() as session:
#        try:
#           yield session
#        finally:
#           await session.close()

Base = postgress.Base

__all__ = ["postgress", "getSession", "Base"]

## app/db/postgress/repositories/revoked_jwt_tokens.py
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError, OperationalError
from sqlalchemy.future import select

from ..models import RevokedToken
from ..engine import postgress
from ....services.scheduler.base_cron import register_cron_job, BaseCronJob
from ....utils.config_helpers import get_property


# Cron jobs

@register_cron_job("TokenPurgeCron")
class TokenPurgeCron(BaseCronJob):
    """Cron job to delete expired tokens from the database."""
    def __init__(self):
        super().__init__("TokenPurgeCron", "auth", ["token_purge_interval"])

    async def run(self, session: AsyncSession):
        """ Delete all expired tokens from the database asynchronously """
        try:
            statement = select(RevokedToken).where(RevokedToken.data_expires < datetime.utcnow())
            result = await session.execute(statement)
            expired_tokens = result.scalars().all()

            for token in expired_tokens:
                await session.delete(token)

            await session.commit()
            return True
        except:
            await session.rollback()
            return False

# Create/Update functions

async def revoke_token(session: AsyncSession, jti: str, expires: datetime, token_type: str, commit=True) -> RevokedToken:
    """ Revoke a token in the database asynchronously

    Args:
        session (AsyncSession): The database session
        jti (str): The JTI of the token
        expires (datetime): The expiration date of the token
        token_type (str): The type of token
        commit (bool, optional): Whether to commit the transaction. Defaults to True.
    """
    try:
        token = RevokedToken(jti=jti, date_revoked=datetime.utcnow(), data_expires=expires, type=token_type)
        session.add(token)
        if commit:
            await session.commit()
        return token
    except IntegrityError:
        await session.rollback()
        print("A token with this JTI already exists.")
        return None
    except OperationalError:
        await session.rollback()
        print("There was an issue with the database operation.")
        return None
    except TypeError as e:
        await session.rollback()
        print(f"Type error: {e}")
        return None

def revoke_token_sync(jti: str, expires: datetime, token_type: str, commit=True) -> RevokedToken:
    """ Revoke a token in the database synchronously """
    session = postgress.SyncSession()
    try:
        token = RevokedToken(jti=jti, date_revoked=datetime.utcnow(), data_expires=expires, type=token_type)
        session.add(token)
        if commit:
            session.commit()
        return token
    except IntegrityError:
        session.rollback()
        print("A token with this JTI already exists.")
        return None
    except OperationalError:
        session.rollback()
        print("There was an issue with the database operation.")
        return None
    except TypeError as e:
        session.rollback()
        print(f"Type error: {e}")
        return None
    finally:
        session.close()

async def get_revoked_token_by_jti(session: AsyncSession, jti: str) -> RevokedToken:
    """ Get a revoked token from the database by JTI asynchronously """
    statement = select(RevokedToken).where(RevokedToken.jti == jti)
    result = await session.execute(statement)
    return result.scalars().first()

def get_revoked_token_by_jti_sync(jti: str) -> RevokedToken:
    """ Get a revoked token from the database by JTI synchronously """
    session = postgress.SyncSession()
    try:
        statement = select(RevokedToken).where(RevokedToken.jti == jti)
        result = session.execute(statement)
        return result.scalars().first()
    finally:
        session.close()


## app/db/postgress/repositories/acc_recovery.py
import yaml
import asyncio
from datetime import datetime, timedelta

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError, OperationalError
from sqlalchemy.orm import joinedload
from sqlalchemy.future import select

from ..models import User, AccountRecovery
from ..engine import postgress
from ....services.auth.verification import generate_verification_code
from ....core.config import Config
from ....services.scheduler.base_cron import register_cron_job, BaseCronJob

try:
    password_reset_code_duration = Config.get_property(None, "verify", ["password_reset_code_duration"])['password_reset_code_duration']
except Exception as e: # if the config file is not found
    print(f"Error loading config: {e}")
# is_config_loaded = False

@register_cron_job("AccountRecoveryPurgeCron")
class AccountRecoveryPurgeCron(BaseCronJob):
    """Cron job to delete expired password resets from the database."""
    def __init__(self):
        super().__init__("AccountRecoveryPurgeCron", "verify", ["password_reset_purge_interval"])

    async def run(self, session: AsyncSession):
        """ Delete all expired password resets from the database asynchronously """
        try:
            statement = select(AccountRecovery).where(AccountRecovery.token_expires < datetime.utcnow())
            result = await session.execute(statement)
            resets = result.scalars().all()
            for reset in resets:
                await session.delete(reset)
            await session.commit()
        except Exception as e:
            print(f"Error deleting expired password resets: {e}")
            await session.rollback()

async def create_acc_recovery(session: AsyncSession, user: User, commit=True, fresh=True) -> AccountRecovery | None:
    """ Create a password reset entry for a user. """
    try:
        reset_token, token_expire = generate_verification_code(32, password_reset_code_duration)
        password_reset = AccountRecovery(user_id=user.id, reset_token=reset_token, token_expires=token_expire)
        session.add(password_reset)
        if commit:
            await session.commit()
        if fresh:
            await asyncio.gather(session.refresh(password_reset), session.refresh(user))
        return password_reset
    except IntegrityError:
        await session.rollback()
        return None
    except OperationalError:
        await session.rollback()
        return None

async def get_acc_recovery_by_token(session: AsyncSession, reset_token: str) -> AccountRecovery | None:
    """ Get a password reset entry by its token. (LOADS USER) """
    try:
        statement = select(AccountRecovery).where(AccountRecovery.reset_token == reset_token).options(joinedload(AccountRecovery.user))
        result = await session.execute(statement)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting password reset by token: {e}")
        return None

async def del_acc_recovery(session: AsyncSession, reset: AccountRecovery, commit=True):
    """ Delete a password reset entry from the database. """
    try:
        await session.delete(reset)
        if commit:
            await session.commit()
    except Exception as e:
        await session.rollback()
        print(f"Error deleting password reset: {e}")
        return False
    return True


## app/db/postgress/repositories/role.py
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError, OperationalError

from ..models import Role

# Create functions

async def create_role(session: AsyncSession, name: str, desc: str, commit=True, refresh=False) -> Role:
    """ Create a role in the database asynchronously

    Args:
        session (AsyncSession): The database session
        name (str): The role's name
        desc (str): The role's description
        commit (bool, optional): Whether to commit the transaction. Defaults to True.
        refresh (bool, optional): Whether to refresh the role object from DB. Defaults to False.
    """
    try:
        role = Role(role_name=name, description=desc)
        session.add(role)
        if commit:
            await session.commit()
        if refresh:
            await session.refresh(role)
        return role
    except IntegrityError:
        await session.rollback()
        print("Role already exists.")
        return None
    except OperationalError:
        await session.rollback()
        print("Database operation failed.")
        return None

# Get functions

async def get_role_by_name(session: AsyncSession, name: str) -> Role | None:
    """ Get a role from the database by name asynchronously """
    statement = select(Role).where(Role.role_name == name)
    result = await session.execute(statement)
    return result.scalars().first()

async def get_role_by_id(session: AsyncSession, role_id: int) -> Role | None:
    """ Get a role from the database by ID asynchronously """
    statement = select(Role).where(Role.id == role_id)
    result = await session.execute(statement)
    return result.scalars().first()

async def get_all_roles(session: AsyncSession) -> list[Role]:
    """ Get all roles from the database asynchronously """
    statement = select(Role)
    result = await session.execute(statement)
    return result.scalars().all()

# Update functions

async def update_role(session: AsyncSession, role: Role, commit=True, refresh=False) -> Role:
    """ Update a role in the database asynchronously

    Args:
        session (AsyncSession): The database session
        role (Role): The role object
        commit (bool, optional): Whether to commit the transaction. Defaults to True.
        refresh (bool, optional): Whether to refresh the role object from DB. Defaults to False.
    """
    try:
        session.add(role)
        if commit:
            await session.commit()
        if refresh:
            await session.refresh(role)
        return role
    except IntegrityError:
        await session.rollback()
        print("A role with this name already exists.")
        return None
    except OperationalError:
        await session.rollback()
        print("There was an issue with the database operation.")
        return None

# Delete functions

async def delete_role(session: AsyncSession, role: Role, commit=True) -> bool:
    """ Delete a role from the database asynchronously

    Args:
        session (AsyncSession): The database session
        role (Role): The role object
        commit (bool, optional): Whether to commit the transaction. Defaults to True.
    """
    try:
        await session.delete(role)
        if commit:
            await session.commit()
        return True
    except Exception:
        await session.rollback()
        print("Failed to delete the role.")
        return False


## app/db/postgress/repositories/__init__.py
from .acc_recovery import *
from .passkey import *
from .revoked_jwt_tokens import *
from .role import *
from .terms_agreements import *
from .user import *
from .user_passions import *
from .user_pictures import *

## app/db/postgress/repositories/user_passions.py
from typing import List, Optional
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError

from ..models import User, UserPassion


async def get_user_passions(session: AsyncSession, user_id: int) -> List[UserPassion]:
    """Get all passions for a user ordered by their defined order."""
    statement = select(UserPassion).where(UserPassion.user_id == user_id).order_by(UserPassion.order)
    result = await session.execute(statement)
    return result.scalars().all()

async def create_user_passion(
    session: AsyncSession, 
    user_id: int, 
    passion_text: str, 
    order: int,
    commit: bool = True
) -> Optional[UserPassion]:
    """Create a new passion for a user."""
    try:
        # Check if user exists
        user_statement = select(User).where(User.id == user_id)
        user_result = await session.execute(user_statement)
        user = user_result.scalars().first()

        if not user:
            print(f"User with ID {user_id} not found")
            return None

        # Check if order is already used
        existing_passion = await get_passion_by_order(session, user_id, order)
        if existing_passion:
            print(f"Order {order} is already used for user {user_id}")
            return None

        passion = UserPassion(
            user_id=user_id,
            passion_text=passion_text,
            order=order
        )
        session.add(passion)

        if commit:
            await session.commit()
            await session.refresh(passion)

        return passion
    except Exception as e:
        await session.rollback()
        print(f"Error creating user passion: {e}")
        return None

async def get_passion_by_order(session: AsyncSession, user_id: int, order: int) -> Optional[UserPassion]:
    """Get a specific passion by its order for a user."""
    statement = select(UserPassion).where(
        UserPassion.user_id == user_id,
        UserPassion.order == order
    )
    result = await session.execute(statement)
    return result.scalars().first()

async def update_user_passion(
    session: AsyncSession, 
    passion_id: int, 
    passion_text: str = None,
    order: int = None,
    commit: bool = True
) -> Optional[UserPassion]:
    """Update an existing passion."""
    try:
        statement = select(UserPassion).where(UserPassion.id == passion_id)
        result = await session.execute(statement)
        passion = result.scalars().first()

        if not passion:
            print(f"Passion with ID {passion_id} not found")
            return None

        if passion_text is not None:
            passion.passion_text = passion_text

        if order is not None and order != passion.order:
            # Check if new order is already used
            existing_passion = await get_passion_by_order(session, passion.user_id, order)
            if existing_passion and existing_passion.id != passion_id:
                print(f"Order {order} is already used")
                return None
            passion.order = order

        session.add(passion)

        if commit:
            await session.commit()
            await session.refresh(passion)

        return passion
    except Exception as e:
        await session.rollback()
        print(f"Error updating user passion: {e}")
        return None

async def delete_user_passion(
    session: AsyncSession, 
    passion_id: int,
    commit: bool = True
) -> bool:
    """Delete a user passion."""
    try:
        statement = select(UserPassion).where(UserPassion.id == passion_id)
        result = await session.execute(statement)
        passion = result.scalars().first()

        if not passion:
            print(f"Passion with ID {passion_id} not found")
            return False

        await session.delete(passion)

        if commit:
            await session.commit()

        return True
    except Exception as e:
        await session.rollback()
        print(f"Error deleting user passion: {e}")
        return False

async def reorder_user_passions(
    session: AsyncSession,
    user_id: int,
    passion_orders: dict,  # {passion_id: new_order}
    commit: bool = True
) -> bool:
    """Reorder multiple passions for a user at once."""
    try:
        # Get all passions for the user
        statement = select(UserPassion).where(UserPassion.user_id == user_id)
        result = await session.execute(statement)
        passions = {p.id: p for p in result.scalars().all()}

        # Update orders
        for passion_id, new_order in passion_orders.items():
            if passion_id in passions:
                passions[passion_id].order = new_order
                session.add(passions[passion_id])

        if commit:
            await session.commit()

        return True
    except Exception as e:
        await session.rollback()
        print(f"Error reordering passions: {e}")
        return False

## app/db/postgress/repositories/terms_agreements.py
from typing import List, Optional, Tuple
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError

from ..models import User, TermsVersion, UserTermsAgreement

async def get_latest_terms_version(session: AsyncSession) -> Optional[TermsVersion]:
    """Get the latest active terms version."""
    statement = select(TermsVersion).where(TermsVersion.is_active == True).order_by(TermsVersion.date_created.desc())
    result = await session.execute(statement)
    return result.scalars().first()

async def get_terms_by_version(session: AsyncSession, version: str) -> Optional[TermsVersion]:
    """Get terms by version string."""
    statement = select(TermsVersion).where(TermsVersion.version == version)
    result = await session.execute(statement)
    return result.scalars().first()

async def get_terms_by_id(session: AsyncSession, terms_id: int) -> Optional[TermsVersion]:
    """Get terms by ID."""
    statement = select(TermsVersion).where(TermsVersion.id == terms_id)
    result = await session.execute(statement)
    return result.scalars().first()

async def create_terms_version(
    session: AsyncSession, 
    version: str,
    content: str,
    is_active: bool = True,
    commit: bool = True
) -> Optional[TermsVersion]:
    """Create a new terms version."""
    try:
        # If new version is active, deactivate all other versions
        if is_active:
            await deactivate_all_terms(session, commit=False)

        terms = TermsVersion(
            version=version,
            content=content,
            is_active=is_active
        )
        session.add(terms)

        if commit:
            await session.commit()
            await session.refresh(terms)

        return terms
    except Exception as e:
        await session.rollback()
        print(f"Error creating terms version: {e}")
        return None

async def deactivate_all_terms(session: AsyncSession, commit: bool = True) -> bool:
    """Deactivate all terms versions."""
    try:
        statement = select(TermsVersion).where(TermsVersion.is_active == True)
        result = await session.execute(statement)
        terms_versions = result.scalars().all()

        for terms in terms_versions:
            terms.is_active = False
            session.add(terms)

        if commit:
            await session.commit()

        return True
    except Exception as e:
        if commit:
            await session.rollback()
        print(f"Error deactivating terms: {e}")
        return False

async def update_terms_version(
    session: AsyncSession,
    terms_id: int,
    content: str = None,
    is_active: bool = None,
    commit: bool = True
) -> Optional[TermsVersion]:
    """Update a terms version."""
    try:
        statement = select(TermsVersion).where(TermsVersion.id == terms_id)
        result = await session.execute(statement)
        terms = result.scalars().first()

        if not terms:
            print(f"Terms with ID {terms_id} not found")
            return None

        if content is not None:
            terms.content = content

        if is_active is not None and is_active != terms.is_active:
            if is_active:
                # If activating this version, deactivate all others
                await deactivate_all_terms(session, commit=False)
            terms.is_active = is_active

        session.add(terms)

        if commit:
            await session.commit()
            await session.refresh(terms)

        return terms
    except Exception as e:
        await session.rollback()
        print(f"Error updating terms version: {e}")
        return None

async def get_user_terms_agreement(session: AsyncSession, user_id: int) -> List[UserTermsAgreement]:
    """Get a user's terms agreements."""
    statement = (
        select(UserTermsAgreement)
        .where(UserTermsAgreement.user_id == user_id)
        .order_by(UserTermsAgreement.date_agreed.desc())
    )
    result = await session.execute(statement)
    return result.scalars().all()

async def get_latest_user_terms_agreement(session: AsyncSession, user_id: int) -> Optional[UserTermsAgreement]:
    """Get a user's most recent terms agreement."""
    statement = (
        select(UserTermsAgreement)
        .where(UserTermsAgreement.user_id == user_id)
        .order_by(UserTermsAgreement.date_agreed.desc())
    )
    result = await session.execute(statement)
    return result.scalars().first()

async def create_user_terms_agreement(
    session: AsyncSession,
    user_id: int,
    terms_id: int,
    commit: bool = True
) -> Tuple[Optional[UserTermsAgreement], bool]:
    """Create a new user terms agreement."""
    try:
        # Check if user exists
        user_statement = select(User).where(User.id == user_id)
        user_result = await session.execute(user_statement)
        user = user_result.scalars().first()

        if not user:
            print(f"User with ID {user_id} not found")
            return None, False

        # Check if terms exists
        terms_statement = select(TermsVersion).where(TermsVersion.id == terms_id)
        terms_result = await session.execute(terms_statement)
        terms = terms_result.scalars().first()

        if not terms:
            print(f"Terms with ID {terms_id} not found")
            return None, False

        # Check if user already agreed to these terms
        existing_agreement = await get_user_specific_agreement(session, user_id, terms_id)
        if existing_agreement:
            return existing_agreement, False

        agreement = UserTermsAgreement(
            user_id=user_id,
            terms_id=terms_id,
            date_agreed=datetime.utcnow()
        )
        session.add(agreement)

        if commit:
            await session.commit()
            await session.refresh(agreement)

        return agreement, True
    except Exception as e:
        await session.rollback()
        print(f"Error creating user terms agreement: {e}")
        return None, False

async def get_user_specific_agreement(session: AsyncSession, user_id: int, terms_id: int) -> Optional[UserTermsAgreement]:
    """Get a specific user-terms agreement."""
    statement = select(UserTermsAgreement).where(
        UserTermsAgreement.user_id == user_id,
        UserTermsAgreement.terms_id == terms_id
    )
    result = await session.execute(statement)
    return result.scalars().first()

async def has_user_agreed_to_latest_terms(session: AsyncSession, user_id: int) -> bool:
    """Check if a user has agreed to the latest terms."""
    latest_terms = await get_latest_terms_version(session)
    if not latest_terms:
        return False

    agreement = await get_user_specific_agreement(session, user_id, latest_terms.id)
    return agreement is not None

## app/db/postgress/repositories/games_data.py
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from ..models.test_model import (
    ScenarioGameData,
    ShapeSequenceGameData,
    JobsGameData,
    SpeedGameData,
    AbilitiesGameData,
    SkillsGameData,
    RoomEnvGameData,
)

# === Scenario Game ===
async def get_scenario_game_data(session: AsyncSession, user_id: int) -> Optional[ScenarioGameData]:
    try:
        stmt = select(ScenarioGameData).where(ScenarioGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting scenario game data: {e}")
        return None
    
async def upsert_scenario_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(ScenarioGameData).where(ScenarioGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = ScenarioGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

# === Shape Sequence Game ===
async def get_shape_sequence_game_data(session: AsyncSession, user_id: int) -> Optional[ShapeSequenceGameData]:
    try:
        stmt = select(ShapeSequenceGameData).where(ShapeSequenceGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting shape sequence game data: {e}")
        return None
    
async def upsert_shape_sequence_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(ShapeSequenceGameData).where(ShapeSequenceGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = ShapeSequenceGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

# === Jobs Game ===
async def get_jobs_game_data(session: AsyncSession, user_id: int) -> Optional[JobsGameData]:
    try:
        stmt = select(JobsGameData).where(JobsGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting jobs game data: {e}")
        return None
    
async def upsert_jobs_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(JobsGameData).where(JobsGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = JobsGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

# === Speed Game ===
async def get_speed_game_data(session: AsyncSession, user_id: int) -> Optional[SpeedGameData]:
    try:
        stmt = select(SpeedGameData).where(SpeedGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting speed game data: {e}")
        return None
    
async def upsert_speed_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(SpeedGameData).where(SpeedGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = SpeedGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

# === Abilities Game ===
async def get_abilities_game_data(session: AsyncSession, user_id: int) -> Optional[AbilitiesGameData]:
    try:
        stmt = select(AbilitiesGameData).where(AbilitiesGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting abilities game data: {e}")
        return None
    
async def upsert_abilities_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(AbilitiesGameData).where(AbilitiesGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = AbilitiesGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

# === Skills Game ===
async def get_skills_game_data(session: AsyncSession, user_id: int) -> Optional[SkillsGameData]:
    try:
        stmt = select(SkillsGameData).where(SkillsGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting skills game data: {e}")
        return None
    
async def upsert_skills_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(SkillsGameData).where(SkillsGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = SkillsGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

# === Room Environment Game ===
async def get_room_env_game_data(session: AsyncSession, user_id: int) -> Optional[RoomEnvGameData]:
    try:
        stmt = select(RoomEnvGameData).where(RoomEnvGameData.user_id == user_id)
        result = await session.execute(stmt)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting room environment game data: {e}")
        return None

async def upsert_room_env_game_data(session: AsyncSession, user_id: int, payload: dict):
    stmt = select(RoomEnvGameData).where(RoomEnvGameData.user_id == user_id)
    result = await session.execute(stmt)
    data = result.scalars().first()

    if data:
        for key, value in payload.items():
            setattr(data, key, value)
    else:
        data = RoomEnvGameData(user_id=user_id, **payload)
        session.add(data)

    await session.commit()
    return data

## app/db/postgress/repositories/user.py
import asyncio
from typing import Optional, Literal
from datetime import datetime
import yaml

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError, OperationalError
from sqlalchemy.future import select
from sqlalchemy.orm import joinedload
from faker import Faker
from pydantic import BaseModel

from ..models import User, UnverifiedDetails, UserDetail, UserAvatarInfo
from ..engine import postgress
from .role import get_role_by_name
from ....services.auth.password import verify_password, hash_password
from ....services.auth.verification import generate_verification_code, generate_random_suffix
from ....services.scheduler.base_cron import register_cron_job, BaseCronJob
from ....utils.config_helpers import get_property
from ....core.config import Config


class DuplicateUserError(Exception):
    """Custom exception for when a user with the same username or email already exists."""
    pass

class RoleNotFoundError(Exception):
    """Custom exception for when a specified role is not found."""
    pass

class UserCreationError(Exception):
    """Custom exception for general errors during user creation."""
    pass

try:
    email_verification_code_duration = Config.get_property(None, "verify", ["email_verification_code_duration"])["email_verification_code_duration"]
except Exception as e: # if the config file is not found
    print(f"Error loading config: {e}")
    email_verification_code_duration = 900
# is_config_loaded = False

# # Cron job functions
@register_cron_job("UnverifiedUserPurgeCron")
class UnverifiedUserPurgeCron(BaseCronJob):
    """Cron job to delete expired unverified users from the database."""
    def __init__(self):
        super().__init__("UnverifiedUserPurgeCron", "verify", ["email_ver_purge_interval"])

    async def run(self, session: AsyncSession):
        """ Delete expired unverified users from the database."""
        try:
            # Select UnverifiedDetails and eagerly load the related User
            statement = (
                select(UnverifiedDetails)
                .where(UnverifiedDetails.token_expires < datetime.utcnow())
                .options(joinedload(UnverifiedDetails.user))  # Eager loading
            )
            result = await session.execute(statement)
            details: list[UnverifiedDetails] = result.scalars().all()

            for detail in details:
                if detail.user:  # Since it's eagerly loaded, this avoids an extra query
                    await session.delete(detail.user)

            await session.commit()
        except Exception as e:
            print(f"Error deleting expired unverified users: {e}")
            await session.rollback()

async def create_user(session: AsyncSession, username: str, email: str, password: str,
                     first_name: str = None, last_name: str = None,
                     role_name: str = "Young Person", phone_number: str = None,
                     address: str = None, hashed=False, commit=True, fresh=True) -> tuple[User, UnverifiedDetails]:
    """Create a user with traditional login in the database asynchronously

    Args:
        session (AsyncSession): The database session
        username (str): The user's username
        email (str): The user's email
        password (str): The user's password
        first_name (str, optional): The user's first name. Defaults to None.
        last_name (str, optional): The user's last name. Defaults to None.
        role_name (str, optional): The user's role. Defaults to "Young Person".
        phone_number (str, optional): The user's phone number. Defaults to None.
        address (str, optional): The user's address. Defaults to None.
        hashed (bool, optional): Whether the password is already hashed. Defaults to False.
        commit (bool, optional): Whether to commit the transaction. Defaults to True.
        fresh (bool, optional): Whether to return a fresh object. Defaults to True.

    Returns:
        tuple[User, UnverifiedDetails]: A tuple containing the created user and unverified details if successful.

    Raises:
        DuplicateUserError: If a user with the same username or email already exists.
        RoleNotFoundError: If the specified role is not found.
        UserCreationError: For other errors during user creation.
    """
    try:
        if not hashed:
            password = hash_password(password)

        role = await get_role_by_name(session, role_name)
        if not role:
            raise RoleNotFoundError(f"Role '{role_name}' not found")

        # Create base user
        user = User(
            username=username,
            is_passkey=False,  # This is a traditional login user
            role_id=role.id,
            role=role
        )
        session.add(user)
        await session.commit()
        await session.refresh(user)

        # Create verification token
        verification_token, expiration = generate_verification_code(email, email_verification_code_duration)

        # Create user detail with email/password
        user_detail = UserDetail(
            user_id=user.id,
            first_name=first_name,
            last_name=last_name,
            phone_number=phone_number,
            address=address,
            email=email,
            password_hash=password
        )
        session.add(user_detail)
        await session.commit()
        await session.refresh(user_detail)

        # Create unverified details linked to user_detail
        unverified_details = UnverifiedDetails(
            user_detail_id=user_detail.id,
            verification_token=verification_token,
            token_expires=expiration
        )
        session.add(unverified_details)

        if commit:
            await session.commit()

        if fresh:
            await asyncio.gather(
                session.refresh(user), 
                session.refresh(user_detail),
                session.refresh(unverified_details)
            )

        return user, unverified_details
    except IntegrityError as e:
        await session.rollback()
        if "email" in str(e) or "username" in str(e):
            raise DuplicateUserError("User with this email or username already exists.") from e
        else:
            raise UserCreationError(f"Database integrity error: {e}") from e
    except RoleNotFoundError:
        raise # Re-raise RoleNotFoundError
    except Exception as e:
        await session.rollback()
        raise UserCreationError(f"Error creating user: {e}") from e

async def get_user_by_email(session: AsyncSession, email: str, load_type: Literal["lazy", "eager"] = "lazy") -> User | None:
    """ Get a user by their email asynchronously

    Args:
        session (AsyncSession): The database session
        email (str): The user's email
        load_type (Literal["lazy", "eager"], optional): The type of loading to use. Defaults to "lazy".

    Returns:
        User | None: The user object if found, None otherwise
    """
    if load_type == "lazy":
        statement = select(User).where(User.email == email)
    elif load_type == "eager":
        statement = (select(User)
        .where(User.email == email)
        .options(joinedload(User.account_recovery), joinedload(User.verification_details)))
    else:
        raise ValueError("Invalid load type")

    result = await session.execute(statement)
    result = result.scalars().first()
    if not result:
        print("User not found")
        return None
    return result

async def get_user_by_id(session: AsyncSession, user_id: int, load_type: Literal["lazy", "eager"] = "lazy") -> User | None:
    """ Get a user by their ID asynchronously

    Args:
        session (AsyncSession): The database session
        user_id (int): The user's ID
        load_type (Literal["lazy", "eager"], optional): The type of loading to use. Defaults to "lazy".

    Returns:
        User | None: The user object if found, None otherwise
    """
    if load_type == "lazy":
        statement = select(User).where(User.id == user_id)
    elif load_type == "eager":
        statement = (select(User)
        .where(User.id == user_id)
        .options(joinedload(User.account_recovery), joinedload(User.verification_details), 
                 joinedload(User.passkey_credentials)))
    else:
        raise ValueError("Invalid load type")

    result = await session.execute(statement)
    result = result.scalars().first()
    if not result:
        print("User not found")
        return None
    return result

async def verify_user(session: AsyncSession, verification_code: str, commit=True, fresh=True) -> User:
    """Verify a user using their verification code.

    Args:
        session (AsyncSession): The database session
        verification_code (str): The verification code
        commit (bool, optional): Whether to commit the transaction. Defaults to True.
        fresh (bool, optional): Whether to return a fresh object. Defaults to True.
    Returns:
        User | None: The user object if successful, None otherwise
    """
    statement = (
        select(UnverifiedDetails)
        .where(UnverifiedDetails.verification_token == verification_code.strip())
        .options(joinedload(UnverifiedDetails.user_detail))
    )
    result = await session.execute(statement)
    unverified_details = result.scalars().first()

    if not unverified_details:
        print("Verification details not found")
        return None

    if unverified_details.token_expires < datetime.utcnow():
        print("Token expired")
        return None

    user_detail = unverified_details.user_detail
    if not user_detail:
        print("User detail not found")
        return None

    # Get the user from user_detail
    statement = select(User).where(User.id == user_detail.user_id)
    result = await session.execute(statement)
    user = result.scalars().first()

    if user:
        await session.delete(unverified_details)
        if commit:
            await session.commit()
        if fresh:
            await session.refresh(user)

    return user

async def del_uvf_user(session: AsyncSession, user: User, commit=True) -> bool:
    """ Delete a user from the database asynchronously

    Args:
        session (AsyncSession): The database session
        user (User): The user object
        commit (bool, optional): Whether to commit the transaction. Defaults to True.

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        await session.delete(user)
        if commit:
            await session.commit()
        return True
    except Exception as e:
        print(f"Error deleting user: {e}")
        await session.rollback()
        return False

async def login_user(session: AsyncSession, password: str, username_or_email: str) -> User | None:
    """Login a user asynchronously with traditional credentials

    Args:
        session (AsyncSession): The database session
        password (str): The user's password
        username_or_email (str): The user's username or email
    Returns:
        User | None: The user object if successful, None otherwise
    """
    # First try username lookup
    statement = select(User).where(User.username == username_or_email)
    result = await session.execute(statement)
    user = result.scalars().first()

    if not user:
        # Try email lookup in UserDetail
        statement = (
            select(User)
            .join(UserDetail, User.id == UserDetail.user_id)
            .where(UserDetail.email == username_or_email)
            .options(joinedload(User.verification_details))
        )
        result = await session.execute(statement)
        user = result.scalars().first()
    else:
        # If user found by username, load verification_details
        statement = (
            select(User)
            .where(User.id == user.id)
            .options(joinedload(User.verification_details))
        )
        result = await session.execute(statement)
        user = result.scalars().first()

    if not user:
        return None

    # Get user details to check password
    statement = select(UserDetail).where(UserDetail.user_id == user.id)
    result = await session.execute(statement)
    user_detail = result.scalars().first()

    if not user_detail or not user_detail.password_hash:
        return None

    if not verify_password(password, user_detail.password_hash):
        return None

    # Update last login timestamp
    user.last_login = datetime.utcnow()
    await session.commit()

    return user

fake = Faker()

async def get_available_usernames(session: AsyncSession, username: str, num_similars=3) -> tuple[bool, list[str]]:
    """ Check if a username is available in the database asynchronously.
        If taken, return a list of similar available usernames.

    Args:
        session (AsyncSession): The database session.
        username (str): The desired username.
        num_similars (int, optional): Number of alternative usernames to suggest. Defaults to 3.

    Returns:
        tuple[bool, list[str]]: A tuple containing a boolean indicating if the username is available
        and a list of suggested usernames if the username is taken.
    """
    # Check if username exists
    statement = select(User.username).where(User.username == username)
    result = await session.execute(statement)
    taken_usernames = set(result.scalars().all())

    if username not in taken_usernames:
        return True, [username]  # Username is available

    if num_similars < 1:
        return False, []  # No suggestions needed

    suggestions = set()
    attempt_size = num_similars + 5  # Generate a few extra usernames

    # FIY: this has the unlikely possibility of generating the same username multiple times and that
    # username being taken, but the chances are very low
    while len(suggestions) < num_similars:
        generated_usernames = {fake.user_name() for _ in range(attempt_size)}
        statement = select(User.username).where(User.username.in_(generated_usernames))
        result = await session.execute(statement)
        taken_usernames = set(result.scalars().all())
        available_usernames = generated_usernames - taken_usernames
        suggestions.update(available_usernames)

    return False, list(suggestions)[:num_similars]

async def update_ver_details(session: AsyncSession, user: User, eagerly_loaded:bool = False, commit=True,) -> UnverifiedDetails:
    """ Update a user's verification details asynchronously

    Args:
        session (AsyncSession): The database session
        user (User): The user object
        eagerly_loaded (bool): Whether the user object is eagerly loaded (defaults to false)
        commit (bool, optional): Whether to commit the transaction. Defaults to True.

    Note: if you dont know if the user object is eagerly loaded, set eagerly_loaded to False
    Returns:
        UnverifiedDetails | None: The updated unverified details object if successful, None otherwise
    """
    if not eagerly_loaded:
        statement = select(UnverifiedDetails).where(UnverifiedDetails.user_id == user.id)
        result = await session.execute(statement)
        unverified_details = result.scalars().first()
    else:
        unverified_details = user.verification_details
    try:
        verification_token, expiration = generate_verification_code(user.email, email_verification_code_duration)
        unverified_details.verification_token = verification_token
        unverified_details.token_expires = expiration
        session.add(unverified_details)
        if commit:
            await session.commit()
        return unverified_details
    except Exception as e:
        print(f"Error updating verification details: {e}")
        await session.rollback()
        return None

## User avatar data storage
class AvatarInfo(BaseModel):
    """ Pydantic model for avatar information """
    avatarGender: Optional[str] = None
    avatarAccessories: Optional[str] = None
    avatarColor: Optional[str] = None
    avatarPassions: Optional[str] = None
    avatarExpression: Optional[str] = None

async def store_avatar_info(session: AsyncSession, user_id: int, data:dict | AvatarInfo, fresh=True, commit=True) -> UserAvatarInfo | None:
    """ Store avatar information in the database asynchronously(IF already exists overwrite it)

    Args:
        session (AsyncSession): The database session
        user_id (int): The user's ID
        data (dict): The avatar information

    Returns:
        UserAvatarInfo | None: The created avatar info object if successful, None otherwise
    """
    if isinstance(data, dict):
        # If data is a dict, convert it to AvatarInfo model
        try:
            data = AvatarInfo(**data)
        except Exception as e:
            print(f"Invalid avatar data: {e}")
            return None
    elif isinstance(data, AvatarInfo):
        # If data is already an AvatarInfo model, use it directly
        pass
    try:
        # Check if the user already has avatar info
        statement = select(UserAvatarInfo).where(UserAvatarInfo.user_id == user_id)
        result = await session.execute(statement)
        avatar_info = result.scalars().first()

        if avatar_info:
            # Update existing avatar info
            for key, value in data.model_dump(exclude_unset=True).items():
                setattr(avatar_info, key, value)
            session.add(avatar_info)
        else:
            # Create new avatar info
            avatar_info = UserAvatarInfo(user_id=user_id, **data.model_dump())
            session.add(avatar_info)

        if commit:
            await session.commit()
        if fresh:
            await session.refresh(avatar_info)
        return avatar_info
    except IntegrityError:
        await session.rollback()
        print("A user with this email or username already exists.")
        return None
    except Exception as e:
        await session.rollback()
        print(f"Error storing avatar info: {e}")
        return None

async def get_avatar_info(session: AsyncSession, user_id: int) -> UserAvatarInfo | None:
    """ Get avatar information for a user asynchronously
    Args:
        session (AsyncSession): The database session
        user_id (int): The user's ID
    Returns:
        UserAvatarInfo | None: The avatar info object if found, None otherwise
    """
    statement = select(UserAvatarInfo).where(UserAvatarInfo.user_id == user_id)
    result = await session.execute(statement)
    avatar_info = result.scalars().first()
    if not avatar_info:
        print("Avatar info not found")
        return None
    return avatar_info

## app/db/postgress/repositories/passkey.py
import base64
import secrets
import json
import asyncio
from datetime import datetime

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError, OperationalError
from sqlalchemy.future import select
from sqlalchemy.orm import joinedload

from ..models import User, PasskeyCredential, Role, UserDetail
from .role import get_role_by_name


async def create_passkey_user(
    session: AsyncSession, 
    first_name: str, 
    last_name: str = None, 
    age: int = None,
    role_name: str = "Young Person", 
    commit: bool = True
) -> User:
    """Create a base passkey user
    
    Args:
        session (AsyncSession): Database session
        first_name (str): User's first name
        last_name (str): User's last name (optional)
        age (int): User's age (optional)
        role_name (str): Role name for the user (default: "Young Person")
        commit (bool): Whether to commit the transaction
    Returns:
        User: The created user or None if there was an error
    """
    try:
        role = await get_role_by_name(session, role_name)
        if not role:
            print("Role not found")
            return None

        # Generate a random username as placeholder
        random_suffix = secrets.token_hex(8)
        temp_username = f"user_{random_suffix}"

        # Create base user
        user = User(
            username=temp_username,
            is_passkey=True,
            role_id=role.id,
            onboarding_complete=False
        )
        session.add(user)

        if commit:
            await session.commit()
            await session.refresh(user)

        # Create user detail
        user_detail = UserDetail(
            user_id=user.id,
            first_name=first_name,
            last_name=last_name,
            age=age
        )
        session.add(user_detail)

        if commit:
            await session.commit()
            await session.refresh(user_detail)
            await session.refresh(user)

        return user
    except Exception as e:
        await session.rollback()
        print(f"Error creating passkey user: {e}")
        return None

async def register_passkey_credential(
    session: AsyncSession,
    user: User,
    credential_id: str,
    public_key: bytes,
    device_type: str = None,
    commit: bool = True,
    fresh: bool = True
) -> PasskeyCredential:
    """
    Register a new passkey credential for a user.

    Args:
        session (AsyncSession): Database session
        user (User): The user to register the credential for
        credential_id (str): WebAuthn credential ID
        public_key (bytes): WebAuthn public key
        device_type (str): Type of device (optional)
        commit (bool): Whether to commit the transaction
        fresh (bool): Whether to refresh the credential from DB

    Returns:
        PasskeyCredential: The registered credential or None if there was an error
    """
    try:
        credential = PasskeyCredential(
            user_id=user.id,
            credential_id=credential_id,
            public_key=public_key,
            device_type=device_type,
            sign_count=0,
            date_created=datetime.utcnow(),
            last_used=datetime.utcnow()
        )

        session.add(credential)

        if commit:
            await session.commit()

        if fresh:
            await session.refresh(credential)

        return credential
    except IntegrityError:
        await session.rollback()
        print("A credential with this ID already exists")
        return None
    except Exception as e:
        await session.rollback()
        print(f"Error registering passkey credential: {e}")
        return None

async def get_user_by_credential_id(session: AsyncSession, credential_id: str) -> User:
    """
    Get a user by their credential ID.

    Args:
        session (AsyncSession): Database session
        credential_id (str): WebAuthn credential ID

    Returns:
        User: The user associated with the credential or None if not found
    """
    try:
        # Query for the credential and eager load the user
        statement = (
            select(PasskeyCredential)
            .where(PasskeyCredential.credential_id == credential_id)
            .options(joinedload(PasskeyCredential.user))
        )
        result = await session.execute(statement)
        credential = result.scalars().first()

        if not credential:
            return None

        # Update the last_used timestamp
        credential.last_used = datetime.utcnow()
        await session.commit()

        return credential.user
    except Exception as e:
        print(f"Error getting user by credential ID: {e}")
        return None

async def get_credential_by_id(session: AsyncSession, credential_id: str) -> PasskeyCredential:
    """
    Get a credential by its ID.

    Args:
        session (AsyncSession): Database session
        credential_id (str): WebAuthn credential ID

    Returns:
        PasskeyCredential: The credential or None if not found
    """
    try:
        statement = select(PasskeyCredential).where(PasskeyCredential.credential_id == credential_id)
        result = await session.execute(statement)
        return result.scalars().first()
    except Exception as e:
        print(f"Error getting credential by ID: {e}")
        return None

async def update_credential_counter(
    session: AsyncSession,
    credential: PasskeyCredential,
    new_sign_count: int,
    commit: bool = True
) -> bool:
    """
    Update the sign counter for a credential.

    Args:
        session (AsyncSession): Database session
        credential (PasskeyCredential): The credential to update
        new_sign_count (int): The new sign count
        commit (bool): Whether to commit the transaction

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        credential.sign_count = new_sign_count
        credential.last_used = datetime.utcnow()

        if commit:
            await session.commit()

        return True
    except Exception as e:
        await session.rollback()
        print(f"Error updating credential counter: {e}")
        return False

async def get_passkey_credentials_for_user(session: AsyncSession, user_id: int) -> list[PasskeyCredential]:
    """
    Get all passkey credentials for a user.

    Args:
        session (AsyncSession): Database session
        user_id (int): User ID

    Returns:
        list[PasskeyCredential]: List of credentials
    """
    try:
        statement = select(PasskeyCredential).where(PasskeyCredential.user_id == user_id)
        result = await session.execute(statement)
        return result.scalars().all()
    except Exception as e:
        print(f"Error getting passkey credentials for user: {e}")
        return []

async def delete_credential(session: AsyncSession, credential: PasskeyCredential, commit: bool = True) -> bool:
    """
    Delete a passkey credential.

    Args:
        session (AsyncSession): Database session
        credential (PasskeyCredential): The credential to delete
        commit (bool): Whether to commit the transaction

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        await session.delete(credential)

        if commit:
            await session.commit()

        return True
    except Exception as e:
        await session.rollback()
        print(f"Error deleting credential: {e}")
        return False

async def update_user_profile(
    session: AsyncSession,
    user: User,
    username: str = None,
    email: str = None,
    phone_number: str = None,
    address: str = None,
    onboarding_complete: bool = None,
    commit: bool = True,
    fresh: bool = True
) -> User:
    """
    Update a user's profile information.

    Args:
        session (AsyncSession): Database session
        user (User): The user to update
        username (str): New username (optional)
        email (str): New email (optional)
        phone_number (str): New phone number (optional)
        address (str): New address (optional)
        onboarding_complete (bool): Whether onboarding is complete (optional)
        commit (bool): Whether to commit the transaction
        fresh (bool): Whether to refresh the user from DB

    Returns:
        User: The updated user or None if there was an error
    """
    try:
        if username is not None:
            user.username = username

        if email is not None:
            user.email = email

        if phone_number is not None:
            user.phone_number = phone_number

        if address is not None:
            user.address = address

        if onboarding_complete is not None:
            user.onboarding_complete = onboarding_complete

        session.add(user)

        if commit:
            await session.commit()

        if fresh:
            await session.refresh(user)

        return user
    except IntegrityError:
        await session.rollback()
        print("A user with this username or email already exists")
        return None
    except Exception as e:
        await session.rollback()
        print(f"Error updating user profile: {e}")
        return None

# async def create_acc_recovery(session: AsyncSession, user: User):
    

## app/db/postgress/repositories/user_pictures.py
from typing import Optional, Tuple
from datetime import datetime
import io

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy import exists
from fastapi import UploadFile, HTTPException, status

from ..models import User, UserPicture

async def get_user_picture(session: AsyncSession, user_id: int, picture_type: str = "avatar") -> Optional[UserPicture]:
    """Get a user's picture by type."""
    statement = select(UserPicture).where(
        UserPicture.user_id == user_id,
        UserPicture.type == picture_type
    )
    result = await session.execute(statement)
    return result.scalars().first()

async def does_picture_exists(
    session: AsyncSession, user_id: int, picture_type: str = "avatar"
) -> bool:
    """Check if a user's picture exists by type."""
    statement = select(exists().where(
        UserPicture.user_id == user_id,
        UserPicture.type == picture_type
    ))
    result = await session.execute(statement)
    return result.scalar()

async def save_picture_chunk(
    session: AsyncSession,
    chunk: bytes,
    is_first_chunk: bool,
    is_last_chunk: bool,
    user_id: int,
    picture_type: str = "avatar",
    commit: bool = False
) -> Optional[UserPicture]:
    """
    Save an image chunk to the database.

    For the first chunk, create or retrieve the picture record.
    For subsequent chunks, append data to the existing record.

    This function now properly handles updating existing pictures
    instead of trying to insert duplicates.

    Args:
        session: Database session
        chunk: Binary chunk of picture data
        is_first_chunk: Whether this is the first chunk
        is_last_chunk: Whether this is the last chunk
        user_id: User ID
        picture_type: Type of picture
        commit: Whether to commit after processing

    Returns:
        The UserPicture object
    """
    try:
        # For the first chunk, verify the user exists and create/update the picture record
        if is_first_chunk:
            # Check if user exists
            user_statement = select(User).where(User.id == user_id)
            user_result = await session.execute(user_statement)
            user = user_result.scalars().first()

            if not user:
                raise ValueError(f"User with ID {user_id} not found")

            # Check if a picture of this type already exists for this user
            existing_picture = await get_user_picture(session, user_id, picture_type)

            if existing_picture:
                # Update existing picture
                existing_picture.picture_data = chunk
                existing_picture.date_updated = datetime.utcnow()
                picture = existing_picture
            else:
                # Create new picture
                picture = UserPicture(
                    user_id=user_id,
                    picture_data=chunk,
                    type=picture_type
                )

            session.add(picture)

            # Store picture object in session for subsequent chunks
            if not hasattr(session, '_custom_attributes'):
                session._custom_attributes = {}
            session._custom_attributes['current_picture'] = picture

            return picture
        else:
            # For subsequent chunks, retrieve picture from session and append data
            if hasattr(session, '_custom_attributes') and 'current_picture' in session._custom_attributes:
                picture = session._custom_attributes['current_picture']

                # Append chunk to existing data
                if picture.picture_data is None:
                    picture.picture_data = chunk
                else:
                    picture.picture_data = picture.picture_data + chunk

                session.add(picture)

                # If this is the last chunk, we can clean up the session attribute
                if is_last_chunk:
                    if hasattr(session, '_custom_attributes'):
                        session._custom_attributes.pop('current_picture', None)

                return picture
            else:
                raise ValueError("No picture found in session for chunked upload")

        # Commit if requested (typically only for the final chunk)
        if commit:
            await session.commit()
            if picture:
                await session.refresh(picture)

        return picture
    except Exception as e:
        if commit:
            await session.rollback()
        print(f"Error saving picture chunk: {e}")
        raise

async def delete_user_picture(
    session: AsyncSession, 
    user_id: int,
    picture_type: str = "avatar",
    commit: bool = True
) -> bool:
    """Delete a user's picture."""
    try:
        picture = await get_user_picture(session, user_id, picture_type)

        if not picture:
            print(f"Picture not found for user {user_id} with type {picture_type}")
            return False

        await session.delete(picture)

        if commit:
            await session.commit()

        return True
    except Exception as e:
        if commit:
            await session.rollback()
        print(f"Error deleting user picture: {e}")
        return False


## app/db/postgress/models/test_model.py
from typing import Optional, List
from datetime import datetime

from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, DateTime, func, LargeBinary, JSON, UniqueConstraint, Float
from sqlalchemy.orm import relationship, Mapped, mapped_column, DeclarativeBase
from sqlalchemy.ext.asyncio import AsyncAttrs

from ..engine import Base
## AUTH


class Role(AsyncAttrs, Base):
    __tablename__ = "roles"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    role_name: Mapped[str] = mapped_column(String, unique=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(String, nullable=True)

    users: Mapped[list["User"]] = relationship(back_populates="role", lazy="selectin")

class UnverifiedDetails(AsyncAttrs, Base):
    __tablename__ = "unverified_details"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    verification_token: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    token_expires: Mapped[DateTime] = mapped_column(DateTime, nullable=False)
    date_created: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())

    
    user_detail_id: Mapped[int] = mapped_column(ForeignKey("user_details.id"), nullable=False, unique=True)
    user_detail: Mapped["UserDetail"] = relationship(back_populates="verification_details", lazy="selectin")

class UserDetail(AsyncAttrs, Base):
    __tablename__ = "user_details"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, unique=True)
    
    # Personal details
    first_name: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    last_name: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    age: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    phone_number: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    address: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    
    # Traditional login details (moved from User)
    email: Mapped[Optional[str]] = mapped_column(String, unique=True, nullable=True)
    password_hash: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    
    # Relationships
    user: Mapped["User"] = relationship(back_populates="user_detail", lazy="selectin")
    verification_details: Mapped[Optional["UnverifiedDetails"]] = relationship(
        back_populates="user_detail", lazy="selectin", uselist=False, cascade="all, delete-orphan"
    )


class UserPicture(AsyncAttrs, Base):
    __tablename__ = "user_pictures"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    picture_data: Mapped[bytes] = mapped_column(LargeBinary, nullable=True)
    date_updated: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now(), onupdate=func.now())
    type: Mapped[str] = mapped_column(String, nullable=False)  # Type of picture (e.g., "profile", "cover")

    user: Mapped["User"] = relationship(back_populates="picture", lazy="selectin")
    
    # Add composite unique constraint
    __table_args__ = (
        UniqueConstraint('user_id', 'type', name='unique_user_picture_type'),
    )

class UserPassion(AsyncAttrs, Base):
    __tablename__ = "user_passions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    passion_text: Mapped[str] = mapped_column(String, nullable=False)
    order: Mapped[int] = mapped_column(Integer, nullable=False)  # To maintain order of passions (1, 2, 3)

    user: Mapped["User"] = relationship(back_populates="passions", lazy="selectin")

class TermsVersion(AsyncAttrs, Base):
    __tablename__ = "terms_versions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    version: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    content: Mapped[str] = mapped_column(String, nullable=False)  # Markdown content
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    date_created: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())

    user_agreements: Mapped[list["UserTermsAgreement"]] = relationship(
        back_populates="terms_version", lazy="selectin", cascade="all, delete-orphan"
    )

class UserTermsAgreement(AsyncAttrs, Base):
    __tablename__ = "user_terms_agreements"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    terms_id: Mapped[int] = mapped_column(ForeignKey("terms_versions.id"), nullable=False)
    date_agreed: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())

    user: Mapped["User"] = relationship(back_populates="terms_agreements", lazy="selectin")
    terms_version: Mapped["TermsVersion"] = relationship(back_populates="user_agreements", lazy="selectin")


class UserAvatarInfo(AsyncAttrs, Base):
    __tablename__ = "user_avatar_info"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    avatarGender: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    avatarAccessories: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    avatarColor: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    avatarPassions: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    avatarExpression: Mapped[Optional[str]] = mapped_column(String, nullable=True)

class User(AsyncAttrs, Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    username: Mapped[Optional[str]] = mapped_column(String, unique=True, nullable=True)
    date_created: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    last_login: Mapped[Optional[DateTime]] = mapped_column(DateTime, nullable=True)
    is_passkey: Mapped[bool] = mapped_column(Boolean, default=True)  # Default to passkey now
    onboarding_complete: Mapped[bool] = mapped_column(Boolean, default=False)

    role_id: Mapped[int] = mapped_column(ForeignKey("roles.id"), nullable=False)
    role: Mapped["Role"] = relationship(back_populates="users", lazy="selectin")

    # Relationships
    passkey_credentials: Mapped[list["PasskeyCredential"]] = relationship(
        back_populates="user", lazy="selectin", cascade="all, delete-orphan"
    )
    user_detail: Mapped[Optional["UserDetail"]] = relationship(
        back_populates="user", lazy="selectin", uselist=False, cascade="all, delete-orphan"
    )
    picture: Mapped[Optional["UserPicture"]] = relationship(
        back_populates="user", lazy="selectin", uselist=False, cascade="all, delete-orphan"
    )
    passions: Mapped[list["UserPassion"]] = relationship(
        back_populates="user", lazy="selectin", cascade="all, delete-orphan"
    )
    terms_agreements: Mapped[list["UserTermsAgreement"]] = relationship(
        back_populates="user", lazy="selectin", cascade="all, delete-orphan"
    )
    account_recovery: Mapped[list["AccountRecovery"]] = relationship(
        back_populates="user", lazy="selectin", cascade="all, delete-orphan"
    )

class AccountRecovery(AsyncAttrs, Base):
    __tablename__ = "account_recovery"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    reset_token: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    token_expires: Mapped[DateTime] = mapped_column(DateTime, nullable=False)
    date_requested: Mapped[Optional[DateTime]] = mapped_column(DateTime, default=func.now())

    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    user: Mapped["User"] = relationship(back_populates="account_recovery", lazy="selectin")


class RevokedToken(AsyncAttrs, Base):
    __tablename__ = "revoked_tokens"

    jti: Mapped[str] = mapped_column(String, primary_key=True)
    date_revoked: Mapped[DateTime] = mapped_column(DateTime, default=func.now())
    data_expires: Mapped[DateTime] = mapped_column(DateTime, nullable=False)
    type: Mapped[str] = mapped_column(String, nullable=False)

class PasskeyCredential(AsyncAttrs, Base):
    __tablename__ = "passkey_credentials"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    credential_id: Mapped[str] = mapped_column(String, unique=True, nullable=False)
    public_key: Mapped[str] = mapped_column(LargeBinary, nullable=False)
    sign_count: Mapped[int] = mapped_column(Integer, default=0)
    device_type: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    date_created: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())
    last_used: Mapped[Optional[DateTime]] = mapped_column(DateTime, nullable=True)

    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    user: Mapped["User"] = relationship(back_populates="passkey_credentials", lazy="selectin")

## DATA

## Schema may change so we do json instead of individual columns
## Data validation does not exist as a result
# class UserSkill(Base): # DEPRECATED
#     __tablename__ = "user_skills"

#     id: Mapped[int] = mapped_column(Integer, primary_key=True)
#     user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
#     skills_data: Mapped[dict] = mapped_column(JSON, nullable=False, default={})
#     # Example:
#     # {
#     #   "empathie": 10,
#     #   "initiative": 8,
#     #   "communication": 12,
#     #   ...
#     # }
#     last_updated: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())

#     # Relationships
#     user: Mapped["User"] = relationship(back_populates="skills")


# ## same shit schema can change
# class UserAbilities(Base): # DEP
#     __tablename__ = "user_abilities"
#     id: Mapped[int] = mapped_column(Integer, primary_key=True)
#     user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
#     abilities_data: Mapped[dict] = mapped_column(JSON, nullable=False, default={})

#     # Example:
#     # {
#     #   "WantToLearn": ["Gestion du stress", ...],
#     #   "Unknow": ["Gestion du stress", ...],
#     #   "Weak": ["Gestion du stress", ...],
#     #   "Strong": ["Gestion du stress", ...],
#     #   "Skipped": ["Gestion du stress", ...],
#     # }

#     last_updated: Mapped[DateTime] = mapped_column(DateTime, server_default=func.now())
#     # Relationships
#     user: Mapped["User"] = relationship(back_populates="abilities")

## game schemas


##scenario game json example
# {
#   "currentLevel": 3,
#   "completion": 37.5,
#   "traits": {
#     "empathy": 4,
#     "diplomacy": 3,
#     "assertiveness": 2,
#     "pragmatism": 5
#   },
# }
class ScenarioGameData(Base):
    __tablename__ = "scenario_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    current_level = mapped_column(Integer, nullable=False, default=0)
    completion = mapped_column(Float, nullable=False, default=0.0)

    traits = mapped_column(JSON, nullable=False, default={})
    penalties = mapped_column(JSON, nullable=False, default={})

# --- 2️⃣ Shape Sequence Game ---
class ShapeSequenceGameData(Base):
    __tablename__ = "shape_sequence_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    completion = mapped_column(Float, nullable=False, default=0.0)
    levelResults = mapped_column(JSON, nullable=False, default={})
    current_level = mapped_column(Integer, nullable=False, default=0)

# --- 3️⃣ Jobs Game ---
class JobsGameData(Base):
    __tablename__ = "jobs_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    completion = mapped_column(Float, nullable=False, default=0.0)
    jobChoices = mapped_column(JSON, nullable=False, default={})  # Assuming it's a dict

# --- 4️⃣ Speed Game ---
class SpeedGameData(Base):
    __tablename__ = "speed_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    current_level = mapped_column(Integer, nullable=False, default=0)
    completion = mapped_column(Float, nullable=False, default=0.0)
    levelStats = mapped_column(JSON, nullable=False, default={})

# --- 5️⃣ Abilities Game ---
class AbilitiesGameData(Base):
    __tablename__ = "abilities_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    completion = mapped_column(Float, nullable=False, default=0.0)
    skillAssessment = mapped_column(JSON, nullable=False, default={})  # Assuming it's a dict

# --- 6️⃣ Skills Game ---
class SkillsGameData(Base):
    __tablename__ = "skills_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    completion = mapped_column(Float, nullable=False, default=0.0)
    skillsAssessment = mapped_column(JSON, nullable=False, default={})  # Assuming it's a dict

# --- 7️⃣ Room env ---
class RoomEnvGameData(Base):
    __tablename__ = "room_env_game_data"

    id = mapped_column(Integer, primary_key=True)
    user_id = mapped_column(ForeignKey("users.id"), nullable=False)

    completion = mapped_column(Float, nullable=False, default=0.0)
    roomData = mapped_column(JSON, nullable=False, default=list)  # Assuming it's a array of json objects

## app/db/postgress/models/__init__.py
from .test_model import *

## app/api/__init__.py
from os import getenv
from .auth import *
from .data import *

if getenv("MODE") == "DEV":
    from .dev import *

## app/api/dev/__init__.py
from .auth_check_endpoints import *
from .table_manipulation import *

## app/api/dev/auth_check_endpoints.py
## Debugging endpoints to check if the access token and refresh token are valid
## FIY: SHOULD NOT BE USED IN PRODUCTION

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint, SecurityRequirement
from ...db.postgress.engine import getSession as GetSession


auth_test = APIRouter(prefix="/dev", tags=["Development"])

@auth_test.get("/test_access_token")
@secured_endpoint()
async def test_access_token_with_session(
    jwt: dict,
    session: AsyncSession = Depends(GetSession)
):
    return {"msg": "Access Token is valid!", "payload": jwt}

@auth_test.get("/test_refresh_token")
@secured_endpoint(security_type=SecurityRequirement.REFRESH_COOKIE)
async def test_refresh_token_with_session(
    refresh_jwt: dict,
    session: AsyncSession = Depends(GetSession)
):
    return {"msg": "Refresh Token is valid!", "payload": refresh_jwt}

AddRouter(auth_test)


## app/api/dev/table_manipulation.py
## Debugging endpoints to manipulate tables in the database
## FIY: SHOULD NOT BE USED IN PRODUCTION

from fastapi import APIRouter, Depends, Path
from sqlalchemy.ext.asyncio import AsyncSession, AsyncEngine
from sqlalchemy.future import select
from sqlalchemy import text, inspect

from ...core.application import AddRouter
from ...db.postgress.engine import getSession, postgress

example_router = APIRouter(prefix="/dev", tags=["Development"])

# Ensure we have a reference to the async engine
async_engine: AsyncEngine = postgress.engine

@example_router.get("/all-tables")
async def all_tables(DB: AsyncSession = Depends(getSession)):
    """Get all tables in the database."""
    async with async_engine.begin() as conn:
        inspector = inspect(conn)
        tables = inspector.get_table_names()
    return {"tables": tables}

# Route used for dropping all tables
@example_router.get("/drop-all-tables")
async def drop_all_tables(DB: AsyncSession = Depends(getSession)):
    """Drop all tables in the database."""
    async with async_engine.begin() as conn:
        inspector = inspect(conn)
        tables = inspector.get_table_names()
        for table in tables:
            await conn.execute(text(f"DROP TABLE {table} CASCADE"))
    return {"message": "All tables dropped"}

@example_router.get("/drop-table/{table_name}")
async def drop_table(table_name: str = Path(..., title="The name of the table to drop."), DB: AsyncSession = Depends(getSession)):
    """Drop a table in the database."""
    await DB.execute(text(f"DROP TABLE {table_name} CASCADE"))
    await DB.commit()
    return {"message": f"{table_name} dropped"}

AddRouter(example_router)  # Add the router to the server

## app/api/data/avatar_generation.py
import asyncio
import base64
from typing import List, Dict, Any, Optional

from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
from os import getenv
from openai import OpenAI

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint
from ...db.postgress.engine import getSession
from ...core.config import Config

# Initialize OpenAI client
try:
    openai_config = Config.get_property(None, "openai", ["base_url"])
    openai_client = OpenAI(
        api_key=getenv("OPENAI_API_KEY","none"),
        base_url=openai_config.get("base_url")  # Optional: for Azure or custom endpoints
    )
    image_settings = Config.get_property(None, "openai", ["image_generation"])
except Exception as e:
    print(f"Warning: OpenAI client initialization failed: {e}")
    openai_client = None

# Pydantic Models
class AvatarGenerationRequest(BaseModel):
    """Request model for avatar generation"""
    gender: str = Field(..., description="Avatar gender: 'boy', 'girl', or 'neutral'")
    accessories: Optional[str] = Field(None, description="Comma-separated accessories or 'none'")
    color: Optional[str] = Field(None, description="Preferred color")
    passion: Optional[str] = Field(None, description="User's passion/interest")
    expression: Optional[str] = Field(None, description="Avatar expression")

class AvatarData(BaseModel):
    """Individual avatar data"""
    id: str = Field(..., description="Unique identifier for this avatar")
    data_url: str = Field(..., description="Base64 data URL of the image")
    prompt_variation: str = Field(..., description="The specific prompt used for this variation")
    revised_prompt: Optional[str] = Field(None, description="The AI-revised prompt (if available)")

class AvatarGenerationResponse(BaseModel):
    """Response model for avatar generation"""
    avatars: List[AvatarData] = Field(..., description="List of generated avatars")
    message: str = Field("Avatars generated successfully", description="Response message")
    generation_time: float = Field(..., description="Total generation time in seconds")

# Router
avatar_router = APIRouter(prefix="/avatars", tags=["Avatar Generation"])

def build_avatar_prompt(gender: str, accessories: Optional[str] = None, 
                       color: Optional[str] = None, passion: Optional[str] = None, 
                       expression: Optional[str] = None, variation_suffix: str = "") -> str:
    """
    Build the avatar generation prompt based on user preferences.
    
    Args:
        gender: Avatar gender ('boy', 'girl', 'neutral')
        accessories: Accessories string
        color: Preferred color
        passion: User's passion
        expression: Avatar expression
        variation_suffix: Additional text to create variation
        
    Returns:
        Complete prompt string for image generation
    """
    # Convert gender to French
    gender_fr = {
        'boy': 'masculin',
        'girl': 'féminin', 
        'neutral': 'neutre'
    }.get(gender, 'neutre')
    
    # Build accessories text
    accessories_text = "sans accessoires particuliers"
    if accessories and accessories != 'none':
        accessories_list = [acc.strip() for acc in accessories.split(',')]
        accessories_text = f"portant les accessoires suivants : {', '.join(accessories_list)}"
    
    # Build color text
    color_text = ""
    if color:
        color_text = f"avec des tons dominants de {color}"
    
    # Build passion text
    passion_text = ""
    if passion and passion != 'none':
        passion_text = f"reflétant la passion pour : {passion}"
    
    # Build expression text
    expression_text = ""
    if expression:
        expression_text = f"avec une expression {expression}"
    
    # Base prompt (preserved from frontend)
    base_prompt = f"""
Créer une illustration numérique en style cartoon réaliste 2D, traits doux,
palette de couleurs naturelle et harmonieuse, rendu propre et professionnel.

Fond : blanc uni pur (#FFFFFF), sans motif, sans dégradé, sans ombre.
Aucun objet, décor, texte ou palette de couleurs autour du personnage.

Personnage : de genre {gender_fr}, {accessories_text}, {color_text}, {passion_text}, {expression_text}.
Vue de face, position debout, le modèle est coupé à la taille, au niveau de la ceinture, proportions naturelles,
cadré et centré dans l'image, bien éclairé, détails soignés sur vêtements et accessoires.
ne coupez jamais la tête de la personne sur la photo.

Objectif : obtenir un avatar haut de gamme, isolé sur fond blanc, prêt pour un détourage automatique et une utilisation professionnelle ou commerciale.
{variation_suffix}
""".strip()
    
    return base_prompt

async def generate_single_avatar(prompt: str, avatar_id: str) -> Dict[str, Any]:
    """
    Generate a single avatar using OpenAI's Responses API with image generation tool.
    
    Args:
        prompt: The image generation prompt
        avatar_id: Unique identifier for this avatar
        
    Returns:
        Dictionary containing avatar data or error information
    """
    if not openai_client:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="OpenAI client not initialized"
        )
    
    try:
        # Use the new Responses API with image generation tool
        response = await asyncio.get_event_loop().run_in_executor(
            None,
            lambda: openai_client.responses.create(
                model="gpt-4.1-mini",  # Use a supported language model
                input=prompt,
                tools=[{
                    "type": "image_generation",
                    "size": image_settings.get("size", "1024x1024"),  # Default size if not specified
                    "quality": image_settings.get("quality", "low"),  # Default quality
                    "output_format": image_settings.get("format", "jpeg"),
                    # "background" : image_settings.get("background", "transparent")  # Default format

                }]
            )
        )
        
        # Extract image data from the response
        image_data = [
            output.result
            for output in response.output
            if output.type == "image_generation_call"
        ]
        
        if not image_data:
            raise Exception("No image generated in response")
        
        # Get the base64 image data
        image_b64 = image_data[0]
        
        # Create data URL
        data_url = f"data:image/png;base64,{image_b64}"
        
        # Extract revised prompt if available
        revised_prompt = prompt  # Default to original
        for output in response.output:
            if output.type == "image_generation_call" and hasattr(output, 'revised_prompt'):
                revised_prompt = output.revised_prompt
                break
        
        return {
            "success": True,
            "data": {
                "id": avatar_id,
                "data_url": data_url,
                "prompt_variation": prompt,
                "revised_prompt": revised_prompt
            }
        }
        
    except Exception as e:
        print(f"Error generating avatar {avatar_id}: {e}")
        return {
            "success": False,
            "error": str(e),
            "avatar_id": avatar_id
        }

@avatar_router.post("/generate", response_model=AvatarGenerationResponse)
@secured_endpoint()
async def generate_avatars(
    request: AvatarGenerationRequest,
    jwt: dict,
):
    """
    Generate 3 avatar variations based on user preferences.
    
    Requires authentication via access token.
    """
    import time
    start_time = time.time()
    
    user_id = jwt["sub"]
    
    try:
        # Create 3 prompt variations for diversity
        prompt_variations = [
            ("avatar_1", "Style légèrement plus doux et arrondi."),
            ("avatar_2", "Avec des détails légèrement plus fins et précis."), 
            ("avatar_3", "Couleurs légèrement plus vives et contrastées.")
        ]
        
        # Build base prompts with variations
        generation_tasks = []
        for avatar_id, variation in prompt_variations:
            full_prompt = build_avatar_prompt(
                gender=request.gender,
                accessories=request.accessories,
                color=request.color,
                passion=request.passion,
                expression=request.expression,
                variation_suffix=variation
            )
            
            # Create async task for each generation
            task = generate_single_avatar(full_prompt, avatar_id)
            generation_tasks.append(task)
        
        # Generate all 3 avatars concurrently (with some delay to avoid rate limits)
        results = []
        for i, task in enumerate(generation_tasks):
            if i > 0:
                # Add small delay between requests to avoid rate limiting
                await asyncio.sleep(1)
            
            result = await task
            results.append(result)
        
        # Process results
        successful_avatars = []
        failed_generations = []
        
        for result in results:
            if result["success"]:
                successful_avatars.append(AvatarData(**result["data"]))
            else:
                failed_generations.append({
                    "avatar_id": result["avatar_id"],
                    "error": result["error"]
                })
        
        # Check if we have at least one successful generation
        if not successful_avatars:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to generate any avatars. Errors: {failed_generations}"
            )
        
        # Log any partial failures
        if failed_generations:
            print(f"Some avatar generations failed for user {user_id}: {failed_generations}")
        
        generation_time = time.time() - start_time
        
        return AvatarGenerationResponse(
            avatars=successful_avatars,
            message=f"Generated {len(successful_avatars)}/3 avatars successfully",
            generation_time=round(generation_time, 2)
        )
        
    except HTTPException:
        raise  # Re-raise HTTP exceptions
    except Exception as e:
        print(f"Unexpected error generating avatars for user {user_id}: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An unexpected error occurred during avatar generation"
        )

@avatar_router.get("/test-connection")
@secured_endpoint()
async def test_openai_connection(jwt: dict):
    """
    Test endpoint to verify OpenAI connection and image generation capability.
    """
    if not openai_client:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="OpenAI client not initialized"
        )
    
    try:
        # Test with a simple image generation call using the new API
        test_response = await asyncio.get_event_loop().run_in_executor(
            None,
            lambda: openai_client.responses.create(
                model="gpt-4.1-mini",
                input="Generate a simple test image of a blue circle",
                tools=[{
                    "type": "image_generation",
                    "size": "1024x1024",
                    "quality": "low"  # Use low quality for testing
                }]
            )
        )
        
        # Check if image was generated
        image_data = [
            output.result
            for output in test_response.output
            if output.type == "image_generation_call"
        ]
        
        if image_data:
            return {
                "status": "success",
                "message": "OpenAI Responses API connection successful",
                "model": "gpt-4.1-mini with image_generation tool",
                "image_generated": True
            }
        else:
            return {
                "status": "partial_success",
                "message": "Connection successful but no image generated",
                "model": "gpt-4.1-mini with image_generation tool",
                "image_generated": False
            }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"OpenAI connection failed: {str(e)}"
        )

# Add router to the application
AddRouter(avatar_router)


## app/api/data/__init__.py
from .user_passions import *
from .user_pictures import *
from .user_profile import *
from .terms import *
from .games import *
from .avatar_generation import *

## app/api/data/games.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Dict, Any, List

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint
from ...db.postgress.engine import getSession
from ...db.postgress.repositories.games_data import (
    get_scenario_game_data,
    get_shape_sequence_game_data,
    get_jobs_game_data,
    get_speed_game_data,
    get_abilities_game_data,
    get_skills_game_data,
    get_room_env_game_data,
    upsert_scenario_game_data,
    upsert_shape_sequence_game_data,
    upsert_jobs_game_data,
    upsert_speed_game_data,
    upsert_abilities_game_data,
    upsert_skills_game_data,
    upsert_room_env_game_data,
)
from pydantic import BaseModel, Field
from typing import Dict, Optional

# === Shared ===
class BaseGamePost(BaseModel):
    completion: float = Field(..., ge=0.0, le=1.0)

class BaseGameResponse(BaseModel):
    completion: float = Field(..., description="Game completion percentage (0.0 to 1.0)")
    message: str = Field("Success", description="Response message")


# === Scenario Game ===
class ScenarioGamePost(BaseGamePost):
    current_level: int
    traits: Dict = {}
    penalties: Dict = {}

# === Shape Sequence ===
class ShapeSequencePost(BaseGamePost):
    levelResults: Dict = {}

# === Jobs ===
class JobsPost(BaseGamePost):
    jobChoices: Dict = {}

# === Speed ===
class SpeedPost(BaseGamePost):
    current_level: int = 0
    levelStats: Dict = {}

# === Abilities ===
class AbilitiesPost(BaseGamePost):
    skillAssessment: Dict = {}

# === Skills ===
class SkillsPost(BaseGamePost):
    skillsAssessment: Dict = {}

class RoomEnvPost(BaseGamePost):
    roomData: List[Dict] = Field(default_factory=list, description="Room environment configuration items")

## === Response Models ===
class ScenarioGameResponse(BaseGameResponse):
    current_level: int = Field(..., description="Current level in the scenario game")
    traits: Dict[str, int] = Field(default_factory=dict, description="Player traits and their values")
    penalties: Dict[str, Any] = Field(default_factory=dict, description="Penalty information")
    
class ShapeSequenceResponse(BaseGameResponse):
    levelResults: Dict[str, Any] = Field(default_factory=dict, description="Results for each completed level")
    current_level: int = Field(..., description="Current level in the shape sequence game")
class JobsGameResponse(BaseGameResponse):
    jobChoices: Dict[str, Any] = Field(default_factory=dict, description="User's job selections and preferences")
    
class SpeedGameResponse(BaseGameResponse):
    current_level: int = Field(0, description="Current level in the speed game")
    levelStats: Dict[str, Any] = Field(default_factory=dict, description="Statistics for each completed level")
    
class AbilitiesGameResponse(BaseGameResponse):
    skillAssessment: Dict[str, Any] = Field(default_factory=dict, description="User's ability self-assessment")
    
class SkillsGameResponse(BaseGameResponse):
    skillsAssessment: Dict[str, Any] = Field(default_factory=dict, description="User's skills assessment data")

class RoomEnvGameResponse(BaseGameResponse):
    roomData: List[Dict[str, Any]] = Field(default_factory=list, description="Room environment configuration items")


games_router = APIRouter(prefix="/games", tags=["Games"])

# === Scenario Game === /games/scenario
@games_router.get("/scenario", response_model=ScenarioGameResponse)
@secured_endpoint()
async def get_scenario_data(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_scenario_game_data(session, user_id)
    if not data:
        return ScenarioGameResponse(
            message="No scenario game data found",
            current_level=0,
            completion=0.0,
            traits={},
            penalties={}
        )

    return ScenarioGameResponse(
        current_level=data.current_level,
        completion=data.completion,
        traits=data.traits,
        penalties=data.penalties,
    )

@games_router.post("/scenario")
@secured_endpoint()
async def post_scenario_data(payload: ScenarioGamePost, jwt: dict, session: AsyncSession = Depends(getSession)):
    data = await upsert_scenario_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Scenario game data saved", "data": data.__dict__}


# === Shape Sequence Game ===
@games_router.get("/shape-sequence", response_model=ShapeSequenceResponse)
@secured_endpoint()
async def get_shape_sequence_data(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_shape_sequence_game_data(session, user_id)
    if not data:
        return ShapeSequenceResponse(
            message="No shape sequence game data found",
            completion=0.0,
            levelResults={}
        )

    return ShapeSequenceResponse(
        completion=data.completion,
        levelResults=data.levelResults,
        current_level=data.current_level,
    )

@games_router.post("/shape-sequence")
@secured_endpoint()
async def post_shape_sequence_data(payload: ShapeSequencePost, jwt: dict, session: AsyncSession = Depends(getSession)):
    data = await upsert_shape_sequence_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Shape sequence game data saved", "data": data.__dict__}


# === Jobs Game ===
@games_router.get("/jobs", response_model=JobsGameResponse)
@secured_endpoint()
async def get_jobs_data(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_jobs_game_data(session, user_id)
    if not data:
        return JobsGameResponse(
            message="No jobs game data found",
            completion=0.0,
            jobChoices={}
        )

    return JobsGameResponse(
        completion=data.completion,
        jobChoices=data.jobChoices,
    )

@games_router.post("/jobs")
@secured_endpoint()
async def post_jobs_data(payload: JobsPost, jwt: dict, session: AsyncSession = Depends(getSession)):
    data = await upsert_jobs_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Jobs game data saved", "data": data.__dict__}


# === Speed Game ===
@games_router.get("/speed", response_model=SpeedGameResponse)
@secured_endpoint()
async def get_speed_data(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_speed_game_data(session, user_id)
    if not data:
        return SpeedGameResponse(
            message="No speed game data found",
            completion=0.0,
            current_level=0,
            levelStats={}
        )

    return SpeedGameResponse(
        completion=data.completion,
        current_level=data.current_level,
        levelStats=data.levelStats,
    )


@games_router.post("/speed")
@secured_endpoint()
async def post_speed_data(payload: SpeedPost, jwt: dict, session: AsyncSession = Depends(getSession)):
    data = await upsert_speed_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Speed game data saved", "data": data.__dict__}


# === Abilities Game ===
@games_router.get("/abilities", response_model=AbilitiesGameResponse)
@secured_endpoint()
async def get_abilities_game_data_endpoint(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_abilities_game_data(session, user_id)
    if not data:
        return AbilitiesGameResponse(
            message="No abilities game data found",
            completion=0.0,
            skillAssessment={}
        )

    return AbilitiesGameResponse(
        completion=data.completion,
        skillAssessment=data.skillAssessment,
    )

@games_router.post("/abilities")
@secured_endpoint()
async def post_abilities_data(payload: AbilitiesPost, jwt: dict, session: AsyncSession = Depends(getSession)):
    data = await upsert_abilities_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Abilities game data saved", "data": data.__dict__}

# === Skills Game ===
@games_router.get("/skills", response_model=SkillsGameResponse)
@secured_endpoint()
async def get_skills_game_data_endpoint(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_skills_game_data(session, user_id)
    if not data:
        return SkillsGameResponse(
            message="No skills game data found",
            completion=0.0,
            skillsAssessment={}
        )

    return SkillsGameResponse(
        completion=data.completion,
        skillsAssessment=data.skillsAssessment,
    )

@games_router.post("/skills")
@secured_endpoint()
async def post_skills_data(payload: SkillsPost, jwt: dict, session: AsyncSession = Depends(getSession)):
    data = await upsert_skills_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Skills game data saved", "data": data.__dict__}

# Add the RoomEnv game endpoint
@games_router.get("/room-env", response_model=RoomEnvGameResponse)
@secured_endpoint()
async def get_room_env_data(jwt: dict, session: AsyncSession = Depends(getSession)):
    user_id = jwt["sub"]
    data = await get_room_env_game_data(session, user_id)
    if not data:
        return RoomEnvGameResponse(
            message="No room environment data found",
            completion=0.0,
            roomData=[]
        )

    return RoomEnvGameResponse(
        completion=data.completion,
        roomData=data.roomData,
    )

@games_router.post("/room-env")
@secured_endpoint()
async def post_room_env_data(payload: RoomEnvPost, jwt: dict, session: AsyncSession = Depends(getSession)):
    # You'll need to implement this repository function
    data = await upsert_room_env_game_data(session, jwt["sub"], payload.model_dump())
    return {"message": "Room environment data saved", "data": data.__dict__}

# Register the router with the main application
AddRouter(games_router)

## app/api/data/user_passions.py
from typing import Dict, List, Optional, Any

from fastapi import APIRouter, Depends, HTTPException, status, Path, Query
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint
from ...db.postgress.engine import getSession
from ...db.postgress.repositories.user_passions import (
    get_user_passions,
    create_user_passion,
    update_user_passion,
    delete_user_passion,
    reorder_user_passions
)
# ============ Pydantic Models for Request/Response ============

class PassionCreate(BaseModel):
    """Model for creating a passion"""
    passion_text: str = Field(..., description="Text describing the passion")
    order: int = Field(..., description="Order of the passion (1, 2, 3)")

class PassionUpdate(BaseModel):
    """Model for updating a passion"""
    passion_text: Optional[str] = Field(None, description="Text describing the passion")
    order: Optional[int] = Field(None, description="Order of the passion (1, 2, 3)")

class PassionResponse(BaseModel):
    """Model for passion response"""
    id: int
    passion_text: str
    order: int

class PassionList(BaseModel):
    """Model for list of passions"""
    passions: List[PassionResponse]

class PassionReorder(BaseModel):
    """Model for reordering passions"""
    passion_orders: Dict[int, int] = Field(..., description="Dictionary of passion IDs to new orders")

# ============ Router ============

passions_router = APIRouter(prefix="/user/passions", tags=["User Passions"])

# ============ Endpoints ============

@passions_router.get("", response_model=PassionList)
@secured_endpoint()
async def get_my_passions(
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Get the current user's passions"""
    user_id = jwt["sub"]
    passions = await get_user_passions(session, user_id)

    return {"passions": [
        {"id": p.id, "passion_text": p.passion_text, "order": p.order}
        for p in passions
    ]}

@passions_router.post("", response_model=PassionResponse, status_code=status.HTTP_201_CREATED)
@secured_endpoint()
async def create_passion(
    passion: PassionCreate,
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Create a new passion for the current user"""
    user_id = jwt["sub"]

    # Check if they already have 3 passions
    existing_passions = await get_user_passions(session, user_id)
    if len(existing_passions) >= 3:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Maximum of 3 passions allowed"
        )

    # Create the passion
    new_passion = await create_user_passion(
        session, user_id, passion.passion_text, passion.order
    )

    if not new_passion:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to create passion. Order may already be in use."
        )

    return {
        "id": new_passion.id,
        "passion_text": new_passion.passion_text,
        "order": new_passion.order
    }

@passions_router.patch("/{passion_id}", response_model=PassionResponse)
@secured_endpoint()
async def update_passion(
    passion_update: PassionUpdate,
    jwt: dict,
    session: AsyncSession = Depends(getSession),
    passion_id: int = Path(..., description="The ID of the passion to update"),
):
    """Update a passion for the current user"""
    user_id = jwt["sub"]

    # Verify the passion belongs to the user
    passions = await get_user_passions(session, user_id)
    if not any(p.id == passion_id for p in passions):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Passion not found"
        )

    # Update the passion
    updated_passion = await update_user_passion(
        session, passion_id, passion_update.passion_text, passion_update.order
    )

    if not updated_passion:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to update passion. Order may already be in use."
        )

    return {
        "id": updated_passion.id,
        "passion_text": updated_passion.passion_text,
        "order": updated_passion.order
    }

@passions_router.delete("/{passion_id}", status_code=status.HTTP_204_NO_CONTENT)
@secured_endpoint()
async def delete_passion(
    jwt: dict,
    session: AsyncSession = Depends(getSession),
    passion_id: int = Path(..., description="The ID of the passion to delete"),
):
    """Delete a passion for the current user"""
    user_id = jwt["sub"]

    # Verify the passion belongs to the user
    passions = await get_user_passions(session, user_id)
    if not any(p.id == passion_id for p in passions):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Passion not found"
        )

    # Delete the passion
    success = await delete_user_passion(session, passion_id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete passion"
        )

@passions_router.post("/reorder", response_model=PassionList)
@secured_endpoint()
async def reorder_passions(
    reorder_data: PassionReorder,
    jwt: dict,
    session: AsyncSession = Depends(getSession),
):
    """Reorder passions for the current user"""
    user_id = jwt["sub"]

    # Verify all passions belong to the user
    passions = await get_user_passions(session, user_id)
    passion_ids = {p.id for p in passions}

    for passion_id in reorder_data.passion_orders.keys():
        if passion_id not in passion_ids:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Passion with ID {passion_id} not found"
            )

    # Reorder the passions
    success = await reorder_user_passions(
        session, user_id, reorder_data.passion_orders
    )

    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to reorder passions"
        )

    # Get updated passions
    updated_passions = await get_user_passions(session, user_id)

    return {"passions": [
        {"id": p.id, "passion_text": p.passion_text, "order": p.order}
        for p in updated_passions
    ]}

# Add the router to the app
AddRouter(passions_router)

## app/api/data/terms.py
from typing import Dict, List, Optional, Any

from fastapi import APIRouter, Depends, HTTPException, status, Path, Query, Request
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint
from ...db.postgress.engine import getSession
from ...db.postgress.repositories.terms_agreements import (
    get_latest_terms_version,
    get_terms_by_version,
    get_terms_by_id,
    create_terms_version,
    update_terms_version,
    get_user_terms_agreement,
    get_latest_user_terms_agreement,
    create_user_terms_agreement,
    has_user_agreed_to_latest_terms
)

# ============ Pydantic Models for Request/Response ============

class TermsVersionCreate(BaseModel):
    """Model for creating a terms version"""
    version: str = Field(..., description="Version identifier (e.g., 'v1.0')")
    content: str = Field(..., description="Markdown content of the terms")
    is_active: bool = Field(True, description="Whether this is the active version")

class TermsVersionUpdate(BaseModel):
    """Model for updating a terms version"""
    content: Optional[str] = Field(None, description="Markdown content of the terms")
    is_active: Optional[bool] = Field(None, description="Whether this is the active version")

class TermsVersionResponse(BaseModel):
    """Model for terms version response"""
    id: int
    version: str
    content: str
    is_active: bool
    date_created: str

class TermsAgreementResponse(BaseModel):
    """Model for terms agreement response"""
    id: int
    terms_id: int
    terms_version: str
    date_agreed: str

class TermsStatus(BaseModel):
    """Model for terms status response"""
    has_agreed: bool
    latest_terms_id: Optional[int] = None
    latest_terms_version: Optional[str] = None
    agreement_date: Optional[str] = None

# ============ Routers ============

# Public router for getting terms
terms_public_router = APIRouter(prefix="/terms", tags=["Terms and Conditions"])

# Protected router for admin operations on terms
# terms_admin_router = APIRouter(prefix="/admin/terms", tags=["Terms and Conditions Admin"])

# Protected router for user agreements
terms_agreement_router = APIRouter(prefix="/user/terms", tags=["User Terms Agreements"])

# ============ Public Endpoints ============

@terms_public_router.get("", response_model=TermsVersionResponse)
async def get_latest_terms(
    session: AsyncSession = Depends(getSession)
):
    """Get the latest active terms and conditions"""
    terms = await get_latest_terms_version(session)

    if not terms:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No active terms found"
        )

    return {
        "id": terms.id,
        "version": terms.version,
        "content": terms.content,
        "is_active": terms.is_active,
        "date_created": terms.date_created.isoformat()
    }

@terms_public_router.get("/{version}", response_model=TermsVersionResponse)
async def get_terms_by_version_string(
    version: str = Path(..., description="Terms version identifier"),
    session: AsyncSession = Depends(getSession)
):
    """Get terms and conditions by version string"""
    terms = await get_terms_by_version(session, version)

    if not terms:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Terms version '{version}' not found"
        )

    return {
        "id": terms.id,
        "version": terms.version,
        "content": terms.content,
        "is_active": terms.is_active,
        "date_created": terms.date_created.isoformat()
    }

# ============ Admin Endpoints ============

# @terms_admin_router.post("", response_model=TermsVersionResponse, status_code=status.HTTP_201_CREATED)
# @secured_endpoint()
# async def create_new_terms_version(
#     terms_data: TermsVersionCreate,
    # jwt: dict,
    # session: AsyncSession = Depends(getSession)
# ):
#     """Create a new terms version (admin only)"""
#     # Check if user is admin
#     user_role = jwt["role"]
#     if user_role not in [1, 2]:  # Super Admin or Admin roles
#         raise HTTPException(
#             status_code=status.HTTP_403_FORBIDDEN,
#             detail="Only administrators can create terms versions"
#         )

#     terms = await create_terms_version(
#         session, terms_data.version, terms_data.content, terms_data.is_active
#     )

#     if not terms:
#         raise HTTPException(
#             status_code=status.HTTP_400_BAD_REQUEST,
#             detail="Failed to create terms version"
#         )

#     return {
#         "id": terms.id,
#         "version": terms.version,
#         "content": terms.content,
#         "is_active": terms.is_active,
#         "date_created": terms.date_created.isoformat()
#     }

# @terms_admin_router.patch("/{terms_id}", response_model=TermsVersionResponse)
# @secured_endpoint()
# async def update_terms_version_admin(
#     terms_update: TermsVersionUpdate,
#     terms_id: int = Path(..., description="Terms ID"),
#     jwt: dict,
#     session: AsyncSession = Depends(getSession)
# ):
#     """Update a terms version (admin only)"""
#     # Check if user is admin
#     user_role = jwt["role"]
#     if user_role not in [1, 2]:  # Super Admin or Admin roles
#         raise HTTPException(
#             status_code=status.HTTP_403_FORBIDDEN,
#             detail="Only administrators can update terms versions"
#         )

#     terms = await update_terms_version(
#         session, terms_id, terms_update.content, terms_update.is_active
#     )

#     if not terms:
#         raise HTTPException(
#             status_code=status.HTTP_404_NOT_FOUND,
#             detail=f"Terms version with ID {terms_id} not found"
#         )

#     return {
#         "id": terms.id,
#         "version": terms.version,
#         "content": terms.content,
#         "is_active": terms.is_active,
#         "date_created": terms.date_created.isoformat()
#     }

# ============ User Agreement Endpoints ============

@terms_agreement_router.get("/status", response_model=TermsStatus)
@secured_endpoint()
async def check_terms_agreement_status(
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Check if the current user has agreed to the latest terms"""
    user_id = jwt["sub"]

    latest_terms = await get_latest_terms_version(session)
    if not latest_terms:
        return {"has_agreed": True}  # No terms to agree to

    has_agreed = await has_user_agreed_to_latest_terms(session, user_id)
    latest_agreement = await get_latest_user_terms_agreement(session, user_id)

    response = {
        "has_agreed": has_agreed,
        "latest_terms_id": latest_terms.id,
        "latest_terms_version": latest_terms.version
    }

    if latest_agreement:
        response["agreement_date"] = latest_agreement.date_agreed.isoformat()

    return response

@terms_agreement_router.post("/{terms_id}/agree", status_code=status.HTTP_201_CREATED)
@secured_endpoint()
async def agree_to_terms(
    jwt: dict,
    session: AsyncSession = Depends(getSession),
    terms_id: int = Path(..., description="Terms ID to agree to"),
):
    """Record user agreement to a specific terms version"""
    user_id = jwt["sub"]

    # Check if terms exist
    terms = await get_terms_by_id(session, terms_id)
    if not terms:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Terms version with ID {terms_id} not found"
        )

    agreement, created = await create_user_terms_agreement(session, user_id, terms_id)

    if not agreement:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record agreement"
        )

    status_code = status.HTTP_201_CREATED if created else status.HTTP_200_OK
    return {
        "message": "Terms agreement recorded successfully",
        "terms_version": terms.version,
        "date_agreed": agreement.date_agreed.isoformat()
    }

@terms_agreement_router.get("/history", response_model=List[TermsAgreementResponse])
@secured_endpoint()
async def get_terms_agreement_history(
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Get the current user's terms agreement history"""
    user_id = jwt["sub"]

    agreements = await get_user_terms_agreement(session, user_id)

    # Fetch terms version for each agreement
    result = []
    for agreement in agreements:
        terms = await get_terms_by_id(session, agreement.terms_id)
        if terms:
            result.append({
                "id": agreement.id,
                "terms_id": agreement.terms_id,
                "terms_version": terms.version,
                "date_agreed": agreement.date_agreed.isoformat()
            })

    return result

# Add the routers to the app
AddRouter(terms_public_router)
# AddRouter(terms_admin_router)
AddRouter(terms_agreement_router)

## app/api/data/user_profile.py
import os
import json

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint
from ...db.postgress.engine import getSession
from ...db.postgress.models import User, UserDetail, UserPassion, UserPicture
from ...db.postgress.repositories.user_passions import get_user_passions, create_user_passion, delete_user_passion
from ...db.postgress.repositories.user import store_avatar_info, get_avatar_info, AvatarInfo

class UserProfileResponse(BaseModel):
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[str] = None
    age: Optional[int] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    passions: Optional[List[Dict[str, Any]]] = []
    has_picture: bool
    onboarding_complete: bool

class ProfileUpdate(BaseModel):
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    email: Optional[str] = None
    age: Optional[int] = None
    phone_number: Optional[str] = None
    address: Optional[str] = None
    onboarding_complete: Optional[bool] = None

profile_router = APIRouter(prefix="/user/profile", tags=["User Profile"])

@profile_router.get("", response_model=UserProfileResponse)
@secured_endpoint()
async def get_my_profile(
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Get the current user's profile information"""
    user_id = jwt["sub"]

    user = await session.get(User, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # Get user detail
    stmt = select(UserDetail).where(UserDetail.user_id == user_id)
    result = await session.execute(stmt)
    user_detail = result.scalars().first()

    # Get user passions
    passions = await get_user_passions(session, user_id)

    # Check if user has a picture
    stmt = select(UserPicture).where(UserPicture.user_id == user_id)
    result = await session.execute(stmt)
    user_picture = result.scalars().first()

    return {
        "username": user.username if user.username else None,
        "first_name": user_detail.first_name if user_detail else None,
        "last_name": user_detail.last_name if user_detail else None,
        "email": user_detail.email if user_detail else None,
        "age": user_detail.age if user_detail else None,
        "phone_number": user_detail.phone_number if user_detail else None,
        "address": user_detail.address if user_detail else None,
        "passions": [
            {"id": p.id, "text": p.passion_text, "order": p.order}
            for p in passions
        ],
        "has_picture": bool(user_picture and user_picture.picture_data),
        "onboarding_complete": user.onboarding_complete
    }

@profile_router.put("")
@secured_endpoint()
async def update_my_profile(
    profile_data: ProfileUpdate,
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Update the current user's profile information"""
    user_id = jwt["sub"]

    # Get user
    user = await session.get(User, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # Get or create user detail
    stmt = select(UserDetail).where(UserDetail.user_id == user_id)
    result = await session.execute(stmt)
    user_detail = result.scalars().first()

    if not user_detail:
        user_detail = UserDetail(user_id=user_id)
        await session.add(user_detail)

    # Update user fields
    # Note: Username is typically immutable in many systems, so this is commented out.
    # if profile_data.username is not None:
    #     user.username = profile_data.username

    if profile_data.onboarding_complete is not None:
        user.onboarding_complete = profile_data.onboarding_complete

    # Update user detail fields
    if profile_data.first_name is not None:
        user_detail.first_name = profile_data.first_name

    if profile_data.last_name is not None:
        user_detail.last_name = profile_data.last_name

    if profile_data.email is not None:
        user_detail.email = profile_data.email

    if profile_data.age is not None:
        user_detail.age = profile_data.age

    if profile_data.phone_number is not None:
        user_detail.phone_number = profile_data.phone_number

    if profile_data.address is not None:
        user_detail.address = profile_data.address

    session.add(user)
    session.add(user_detail)
    await session.commit()

    return {"message": "Profile updated successfully"}


## avatar data
@profile_router.post("/avatar-creation-data")
@secured_endpoint()
async def process_avatar_creation_data(
    data: AvatarInfo,
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Process avatar creation data"""
    user_id = jwt["sub"]

    try:
        await store_avatar_info(session, user_id, data)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An error occurred while processing avatar creation data"
        )

    return {"message": "Avatar creation data processed successfully"}

@profile_router.get("/avatar-creation-data", response_model=AvatarInfo)
@secured_endpoint()
async def get_avatar_creation_data(
    jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """Get avatar creation data"""
    user_id = jwt["sub"]

    async with session.begin():
        # Get user
        user = await session.get(User, user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )

        # Get avatar info
        avatar_info = await get_avatar_info(session, user_id)

        if not avatar_info:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Avatar creation data not found"
            )
    avatar_info = {
        "avatarGender" : avatar_info.avatarGender,
        "avatarAccessories" : avatar_info.avatarAccessories,
        "avatarColor" : avatar_info.avatarColor,
        "avatarPassions" : avatar_info.avatarPassions,
        "avatarExpression" : avatar_info.avatarExpression,
    }
    return avatar_info

AddRouter(profile_router)

## app/api/data/user_pictures.py
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.decorators import secured_endpoint
from ...core.picture_config import picture_config
from ...db.postgress.engine import getSession
from ...db.postgress.repositories.user_pictures import (
    save_picture_chunk,
    delete_user_picture,
    does_picture_exists
)
from ...utils.image_handler import (
    stream_avif_to_db,
    convert_to_avif_and_save,
    validate_image,
    get_streaming_response_for_image
)

# ============ Router ============

pictures_router = APIRouter(prefix="/user/picture", tags=["User Pictures"])

# ============ Endpoints ============

@pictures_router.get("")
@secured_endpoint()
async def get_my_picture(
    jwt: dict,
    picture_type: str = "profile",
    session: AsyncSession = Depends(getSession)
):
    """
    Get the current user's picture with memory-efficient streaming

    The image is streamed directly from the database to the client
    without loading the entire image into memory at once.
    """
    user_id = jwt["sub"]

    try:
        # Create streaming response using core pool
        if not await does_picture_exists(session, user_id, picture_type):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"No picture found for type '{picture_type}'"
            )
        return await get_streaming_response_for_image(user_id, picture_type)
    except HTTPException:
        # Re-raise HTTP exceptions
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error retrieving image: {str(e)}"
        )

@pictures_router.post("", status_code=status.HTTP_201_CREATED)
@secured_endpoint()
async def upload_picture(
    jwt: dict,
    session: AsyncSession = Depends(getSession),
    picture: UploadFile = File(...),
    picture_type: str = Form("profile"),
    is_avif: bool = Form(False),
    quality: Optional[int] = Form(None),
):
    """
    Upload a picture for the current user with memory-efficient streaming

    Args:
        picture: The image file to upload
        picture_type: Type of picture (profile, cover, etc.)
        is_avif: Whether the image is already in AVIF format (converted client-side)
        quality: AVIF quality (0-100), defaults to the configuration value
    """
    user_id = jwt["sub"]

    # Use specified quality or fallback to config
    avif_quality = quality if quality is not None else picture_config.avif_quality

    # Process the image based on whether it's already AVIF or needs conversion
    if is_avif and picture.content_type == 'image/avif':
        # Direct streaming of AVIF image
        result = await stream_avif_to_db(
            session, 
            picture, 
            save_picture_chunk,
            user_id,
            picture_type
        )
    else:
        # Convert to AVIF and save
        result = await convert_to_avif_and_save(
            session, 
            picture, 
            save_picture_chunk,
            user_id,
            picture_type,
            quality=avif_quality
        )

    if not result:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save picture"
        )

    return {
        "message": f"Picture of type '{picture_type}' uploaded successfully",
        "picture_type": picture_type,
        "is_avif": True,
        "dimensions": {
            "max_width": picture_config.max_width,
            "max_height": picture_config.max_height
        }
    }

@pictures_router.delete("", status_code=status.HTTP_204_NO_CONTENT)
@secured_endpoint()
async def delete_picture(
    jwt: dict,
    session: AsyncSession = Depends(getSession),
    picture_type: str = "profile",
):
    """Delete the current user's picture"""
    user_id = jwt["sub"]

    success = await delete_user_picture(session, user_id, picture_type)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No picture found to delete"
        )

# Add the router to the app
AddRouter(pictures_router)

## app/api/auth/passkeys.py
import os
import json
import secrets
from typing import Dict, Any, Optional, List

from fastapi import APIRouter, HTTPException, Depends, Request, status, Response, File, Form, UploadFile
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.token_creation import create_token, set_refresh_cookie
from ...db.postgress.engine import getSession
from ...db.postgress.models import User, UserDetail, UserPicture, UserPassion
from ...db.postgress.repositories.passkey import (
    create_passkey_user, #needs to be fixxed
    register_passkey_credential,
    get_user_by_credential_id, #needs to be fixxed
    get_credential_by_id,
    update_credential_counter,
    update_user_profile #needs to be fixxed
)
from ...db.postgress.repositories.role import get_role_by_name
from ...services.auth.webauthn import (
    generate_passkey_registration_options,
    verify_passkey_registration,
    generate_passkey_authentication_options,
    verify_passkey_authentication
)

router = APIRouter(prefix="/auth/passkey", tags=["Passkey Authentication"])

# ----- Data Models -----

class PasskeyRegistrationStart(BaseModel):
    first_name: Optional[str] = Field(None, description="User's first name")
    last_name: Optional[str] = Field(None, description="User's last name")
    age: Optional[int] = Field(None, description="User's age")
class PasskeyRegistrationOptions(BaseModel):
    options: Dict[str, Any] = Field(..., description="WebAuthn registration options")
    user_id: int = Field(..., description="User ID")

class PasskeyRegistrationComplete(BaseModel):
    user_id: int = Field(..., description="User ID")
    registration_data: Dict[str, Any] = Field(..., description="WebAuthn registration data")
    challenge: str = Field(..., description="Registration challenge")

class PasskeyRegistrationResult(BaseModel):
    success: bool = Field(..., description="Whether registration was successful")
    access_token: str = Field(..., description="JWT access token")
    message: str = Field("Registration successful", description="Success message")

class PasskeyAuthenticationStart(BaseModel):
    credential_id: Optional[str] = Field(None, description="Credential ID (if known)")

class PasskeyAuthenticationOptions(BaseModel):
    options: Dict[str, Any] = Field(..., description="WebAuthn authentication options")

class PasskeyAuthenticationComplete(BaseModel):
    authentication_data: Dict[str, Any] = Field(..., description="WebAuthn authentication data")
    challenge: str = Field(..., description="Authentication challenge")

class PasskeyAuthenticationResult(BaseModel):
    success: bool = Field(..., description="Whether authentication was successful")
    access_token: str = Field(..., description="JWT access token")
    user_id: int = Field(..., description="User ID")
    is_new_user: bool = Field(..., description="Whether this is a new user")
    onboarding_complete: bool = Field(..., description="Whether onboarding is complete")
    message: str = Field("Authentication successful", description="Success message")

class UpdateUserProfile(BaseModel):
    username: Optional[str] = Field(None, description="Username")
    email: Optional[str] = Field(None, description="Email")
    phone_number: Optional[str] = Field(None, description="Phone number")
    address: Optional[str] = Field(None, description="Address")
    onboarding_complete: Optional[bool] = Field(None, description="Whether onboarding is complete")

# ----- Endpoints -----

@router.post("/registration/start", response_model=PasskeyRegistrationOptions)
async def start_passkey_registration(
    data: PasskeyRegistrationStart,
    session: AsyncSession = Depends(getSession)
):
    """
    Start the passkey registration process by creating a minimal user profile
    and generating WebAuthn registration options.
    
    All fields are optional, allowing the creation of a dummy empty account
    that can be populated with user data later.
    """
    try:
        # Transaction for creating user and related data
        # 1. Create the base user with default role
        role = await get_role_by_name(session, "Young Person")
        if not role:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Default role not found"
            )

        # Generate a random username as placeholder
        random_suffix = secrets.token_hex(8)
        temp_username = f"user_{random_suffix}"

        user = User(
            username=temp_username,
            is_passkey=True,
            role_id=role.id,
            onboarding_complete=False
        )
        session.add(user)
        await session.flush()  # Get the user ID

        # 2. Create the user detail entry (all fields optional)
        user_detail = UserDetail(
            user_id=user.id,
            first_name=data.first_name,
            last_name=data.last_name,
            age=data.age
        )
        session.add(user_detail)
        await session.flush()  # Ensure user_detail is created
        # Generate registration options with appropriate display name
        display_name = "Autrement Capable"
        if data.first_name:
            display_name = f"{data.first_name}"
            if data.last_name:
                display_name += f" {data.last_name}"
                
        options = generate_passkey_registration_options(user.id, display_name)

        await session.commit()  # Commit the transaction
        return {
            "options": options,
            "user_id": user.id
        }
    except HTTPException:
        raise  # Re-raise HTTP exceptions
    except Exception as e:
        print(f"Error in passkey registration: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create user profile"
        )

@router.post("/registration/complete", response_model=PasskeyRegistrationResult)
async def complete_passkey_registration(
    data: PasskeyRegistrationComplete,
    response: Response,
    session: AsyncSession = Depends(getSession)
):
    """
    Complete the passkey registration process by verifying the registration response
    and storing the credential.

    The refresh token is automatically stored in an HTTP-only cookie.
    """
    # Verify registration response
    verification = verify_passkey_registration(
        user_id=data.user_id,
        options_challenge=data.challenge,
        registration_data=data.registration_data
    )

    if not verification:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to verify registration"
        )

    # Get the user
    from ...db.postgress.repositories.user import get_user_by_id
    user = await get_user_by_id(session, data.user_id)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # Register credential
    credential = await register_passkey_credential(
        session=session,
        user=user,
        credential_id=verification["credential_id"],
        public_key=verification["public_key"],
        device_type="platform"  # Assuming this is a platform passkey
    )

    if not credential:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to register credential"
        )

    # Create tokens
    access_token = create_token(user.id, user.role_id, refresh=False, fresh=True)
    refresh_token = create_token(user.id, user.role_id, refresh=True, fresh=True)

    # Set refresh token in HTTP-only cookie
    set_refresh_cookie(response, refresh_token)

    return {
        "success": True,
        "access_token": access_token,
        "message": "Passkey registration successful"
    }

@router.post("/authentication/start", response_model=PasskeyAuthenticationOptions)
async def start_passkey_authentication(
    data: PasskeyAuthenticationStart = None,
    session: AsyncSession = Depends(getSession)
):
    """
    Start the passkey authentication process by generating WebAuthn authentication options.
    """
    # Generate authentication options
    options = generate_passkey_authentication_options()

    return {
        "options": options
    }

@router.post("/authentication/complete", response_model=PasskeyAuthenticationResult)
async def complete_passkey_authentication(
    data: PasskeyAuthenticationComplete,
    response: Response,
    session: AsyncSession = Depends(getSession)
):
    """
    Complete the passkey authentication process by verifying the authentication response.

    The refresh token is automatically stored in an HTTP-only cookie.
    """
    # Extract credential ID from authentication data
    credential_id = data.authentication_data.get("id")

    if not credential_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Missing credential ID"
        )

    # Get credential from database
    credential = await get_credential_by_id(session, credential_id)

    if not credential:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Credential not found"
        )

    # Get user
    user = credential.user

    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    # Verify authentication response
    verification = verify_passkey_authentication(
        credential_id=credential.credential_id,
        public_key=credential.public_key,
        current_sign_count=credential.sign_count,
        options_challenge=data.challenge,
        authentication_data=data.authentication_data
    )

    if not verification:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to verify authentication"
        )

    # Update sign count
    await update_credential_counter(
        session=session,
        credential=credential,
        new_sign_count=verification["new_sign_count"]
    )

    # Create tokens
    access_token = create_token(user.id, user.role_id, refresh=False, fresh=True)
    refresh_token = create_token(user.id, user.role_id, refresh=True, fresh=True)

    # Set refresh token in HTTP-only cookie
    set_refresh_cookie(response, refresh_token)

    return {
        "success": True,
        "access_token": access_token,
        "user_id": user.id,
        "is_new_user": not user.onboarding_complete,
        "onboarding_complete": user.onboarding_complete,
        "message": "Passkey authentication successful"
    }

# Handle passkeys registration to an existing account
@router.post("/rec-acc-passkey", response_model=PasskeyRegistrationOptions)
async def rec_acc_passkey(
    code: str,
    session: AsyncSession = Depends(getSession)
):
    """
    Create a new passkey for existing account using a recovery code.
    you must follow up with a call to /auth/passkey/registration/complete to
    complete the registration of new passkey (old passkey does not get deleted)
    """
    # Get the user from the recovery code
    from ...db.postgress.repositories.acc_recovery import get_acc_recovery_by_token
    recovery = await get_acc_recovery_by_token(session, code)
    if not recovery:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recovery code not found"
        )
    user = recovery.user

    # Generate registration options
    options = generate_passkey_registration_options(user.id, user.first_name)

    return {
        "options": options,
        "user_id": user.id
    }

# Add router to the server
AddRouter(router)


## app/api/auth/login_register_trad.py
## !! likey has race condtion bugs with await and session.rollback() needs to be checked in the future

import os

from fastapi import APIRouter, HTTPException, Depends, status, Response
from pydantic import BaseModel, EmailStr
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.token_creation import create_token, set_refresh_cookie
from ...db.postgress.engine import getSession as GetSession
from ...db.postgress.repositories.user import create_user, login_user, get_available_usernames, del_uvf_user, DuplicateUserError, RoleNotFoundError, UserCreationError
from ...services.mail.repositories.verify_account import send_verification_email

router = APIRouter(prefix="/auth", tags=["Authentication"])

class LoginForm(BaseModel):
    username_or_email: str
    password: str

class LoginResponse(BaseModel):
    access_token: str
    message: str = "Login successful"

class RegisterForm(BaseModel):
    first_name: str
    last_name: str
    phone_number: str
    address: str
    username: str
    email: EmailStr
    password: str

@router.post("/login", response_model=LoginResponse)
async def login(form: LoginForm, response: Response, session: AsyncSession = Depends(GetSession)):
    """
    Login a user and return an access token.
    The refresh token is automatically stored in an HTTP-only cookie.
    """
    user = await login_user(session, form.password, form.username_or_email)
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")
    if user.verification_details is not None:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Account not verified")

    # Create tokens
    access_token = create_token(user.id, user.role_id, refresh=False, fresh=True)
    refresh_token = create_token(user.id, user.role_id, refresh=True, fresh=True)

    # Set refresh token in HTTP-only cookie
    set_refresh_cookie(response, refresh_token)

    return {"access_token": access_token, "message": "Login successful"}

@router.post("/register")
async def register(form: RegisterForm, session: AsyncSession = Depends(GetSession)):
    """
    Register a new user and send verification email
    """
    test,_ = await get_available_usernames(session, form.username, 0)
    if not test:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Username already taken")

    try:
        tmp_user, details = await create_user(session, form.username,form.email,
                                                form.password, first_name=form.first_name,
                                                last_name=form.last_name, phone_number=form.phone_number,
                                                address=form.address, fresh=True)
    except DuplicateUserError as e:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=str(e))
    except RoleNotFoundError as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))
    except UserCreationError as e:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e))

    try:
        if not await send_verification_email(tmp_user, details):
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to send verification email")
    except Exception as e: # if the email sending fails, delete the user
        await del_uvf_user(session, tmp_user)
        if os.getenv("MODE", False) == "DEV":
            raise # propagate the error
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to send verification email")
    return {"message": "Verification email sent"}

@router.get("/check_username")
async def check_username(username: str, session:AsyncSession = Depends(GetSession)):
    """ Check if a username is already taken

    Use this when registering a new user to check if the username is already taken,
    before attempting to create the user.
    this also gives suggestions for similar usernames.
    /auth/check_username?username=example
    """
    is_available, usernames = await get_available_usernames(session, username)

    return {"is_available": is_available, "usernames": usernames}

AddRouter(router)


## app/api/auth/account_recovery.py
from datetime import datetime
from os import getenv

from fastapi import APIRouter, Depends, Request, HTTPException, Response
from pydantic import BaseModel, Field, EmailStr
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.token_creation import create_token, set_refresh_cookie
from ...core.security.decorators import secured_endpoint
from ...db.postgress.engine import getSession as GetSession
from ...db.postgress.repositories.acc_recovery import get_acc_recovery_by_token, del_acc_recovery, create_acc_recovery
from ...db.postgress.repositories.user import get_user_by_id
from ...services.auth.password import hash_password
router = APIRouter(prefix="/recovery", tags=["Account Recovery"])

class ResetForm(BaseModel):
    password: str = Field(..., title="The new password.", description="The new password for the user.")
    token: str = Field(..., title="The password reset token.", description="The password reset token.")

class TokenResponse(BaseModel):
    access_token: str = Field(..., title="The access token.", description="The access token for the user.")
    message: str = Field("Password reset successful", description="Success message")

@router.get("/is-valid-reset", response_model=dict, responses={200: {"valid": True}, 404: {"valid": False}})
async def is_valid_reset(request: Request, token: str, session: AsyncSession = Depends(GetSession)):
    """
    Check if a password reset token is valid.
    This should be called first by the frontend to check if the token is valid before allowing the user to reset their password.
    """
    reset = await get_acc_recovery_by_token(session, token)
    if not reset or reset.token_expires < datetime.now():
        return {"valid": False}, 404
    return {"valid": True}

@router.post("/reset-password", response_model=TokenResponse)
async def reset_password(
    request: Request, 
    form: ResetForm, 
    response: Response,
    session: AsyncSession = Depends(GetSession)
):
    """
    Reset a user's password.

    The refresh token is automatically stored in an HTTP-only cookie.
    """
    reset = await get_acc_recovery_by_token(session, form.token)
    if not reset or reset.token_expires < datetime.now():
        raise HTTPException(status_code=404, detail="Token not found or has expired.")
    user = reset.user
    user.password_hash = hash_password(form.password)

    try:
        user.account_recovery = [] # should work cause of cascade set to orphab-delete
        session.add(user)
        await session.commit()
    except Exception as e:
        await session.rollback()
        raise HTTPException(status_code=500, detail="An error occurred while updating the user's password.")

    access_token = create_token(user.id, user.role_id, refresh=False, fresh=True)
    refresh_token = create_token(user.id, user.role_id, refresh=True, fresh=True)

    # Set refresh token in HTTP-only cookie
    set_refresh_cookie(response, refresh_token)

    await del_acc_recovery(session, reset)
    return {"access_token": access_token, "message": "Password reset successful"}

@router.get("/create-account-recovery", response_model=dict,
responses={200: {"message": "Account recovery created."}})
@secured_endpoint()
async def create_account_recovery(
    request: Request,
    jwt:dict,
    session: AsyncSession = Depends(GetSession),
):
    """
    Create an account recovery for a user. (Used when transferring to a new device that does not have registered passkeys)
    """
    user_id = jwt["sub"]
    user = await get_user_by_id(session, user_id)
    if not user:
        raise HTTPException(status_code=404, detail="User not found.")
    if user.account_recovery: # dont know if this is the right way to check if the user has an account recovery
        raise HTTPException(status_code=400, detail="Account recovery already exists.")
    recovery_code = await create_acc_recovery(session, user)
    if not recovery_code:
        raise HTTPException(status_code=500, detail="An error occurred while creating the account recovery.")
    return {"recover_code": recovery_code.reset_token}

AddRouter(router)

## app/api/auth/auth_operations.py
import datetime
from typing import Optional

from fastapi import APIRouter, Depends, Request, HTTPException, Response, Cookie
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, Field

from ...core.security.token_creation import create_token, decode_token, set_refresh_cookie, clear_refresh_cookie
from ...core.security.decorators import secured_endpoint, SecurityRequirement
from ...core.errors import create_response_dict
from ...db.postgress.engine import getSession
from ...db.postgress.repositories.revoked_jwt_tokens import revoke_token
from ...core.application import AddRouter
from ...utils import patterns

router = APIRouter(prefix="/auth", tags=["Authentication"])

# Response Models
class LogoutResponse(BaseModel):
    msg: str = Field(..., description="The message")

class RefreshResponse(BaseModel):
    access_token: str = Field(..., description="The new access token")

class MeResponse(BaseModel):
    user_id: int = Field(..., description="The ID of the authenticated user")
    role: str = Field(..., description="The role of the authenticated user")
    msg: str = Field(..., description="A message indicating successful authentication")

@router.post("/refresh",
             response_model=RefreshResponse,
             responses=create_response_dict(AccessToken=False))
@secured_endpoint(security_type=SecurityRequirement.REFRESH_COOKIE)
async def refresh(
    response: Response,
    refresh_jwt: dict,
):
    """
    Refresh the access token. Requires a valid refresh token stored in an HTTP-only cookie.

    The refresh token comes from an HTTP-only cookie, and a new access token is returned in the response body.
    """
    try:
        # Decode the refresh token from the cookie
        jwt_payload = refresh_jwt

        # Create a new access token
        access_token = create_token(jwt_payload["sub"], jwt_payload["role"], refresh=False)

        # Generate a new refresh token for security reasons
        new_refresh_token = create_token(jwt_payload["sub"], jwt_payload["role"], refresh=True)

        # Set the new refresh token as a cookie
        set_refresh_cookie(response, new_refresh_token)

        return {"access_token": access_token}
    except Exception as e:
        # If the token validation fails, clear the cookie
        clear_refresh_cookie(response)
        raise

@router.post("/logout",
             responses=create_response_dict(),
             response_model=LogoutResponse)
@secured_endpoint(security_type=SecurityRequirement.BOTH_TOKENS)
async def logout(
    response: Response,
    jwt: dict,
    refresh_jwt: dict,
    session: AsyncSession = Depends(getSession)
):
    """
    Revoke access and refresh tokens to log out the user.

    The access token is provided in the Authorization header.
    The refresh token is automatically retrieved from the HTTP-only cookie.
    Both tokens are revoked on the server and the refresh cookie is cleared.
    """

    jti_access = jwt["jti"]
    expires_access = datetime.utcfromtimestamp(jwt["exp"])

    # Revoke the access token
    is_ok = await revoke_token(session, jti_access, expires_access, "access", commit=False)
    if not is_ok:
        await session.rollback()  # Rollback the session if revocation fails
        raise HTTPException(status_code=401, detail="Invalid access token (Already Revoked)")

    # Clear the refresh cookie
    clear_refresh_cookie(response)

    # Revoke the refresh token if it exists

    if refresh_jwt:
        try:
            jti_refresh = refresh_jwt.get("jti")
            expires_refresh = datetime.utcfromtimestamp(refresh_jwt["exp"])
            await revoke_token(session, jti_refresh, expires_refresh, "refresh")
        except Exception:
            # If token is invalid, we just continue as we already cleared the cookie
            pass
    else:
        await session.rollback()
        raise HTTPException(status_code=401, detail="Invalid refresh token")

    return {"msg": "Successfully logged out"}
# endpoint to check if user is authenticated
@router.get("/status", responses=create_response_dict(AccessToken=False), response_model=MeResponse)
@secured_endpoint(security_type=SecurityRequirement.ACCESS_TOKEN)
async def is_authenticated(
    jwt: dict,
):
    """
    Check if the user is authenticated.

    This endpoint verifies the access token and returns a success message if valid.
    """
    user_id = jwt.get("sub")
    
    if not user_id:
        raise HTTPException(status_code=401, detail="Invalid access token")

    return {"msg": "User is authenticated", "user_id": user_id, "role" : str(jwt.get("role"))}

AddRouter(router)

## app/api/auth/__init__.py
from .account_recovery import *
from .auth_operations import *
from .email_verification import *
from .login_register_trad import *
from .passkeys import *

## app/api/auth/email_verification.py
## !!! like has race condition bugs needs to be check in the future

import os
from datetime import datetime
from os import getenv

from fastapi import APIRouter, Depends, Request, HTTPException, Response, Cookie, status, Query
from fastapi.responses import RedirectResponse
from pydantic import BaseModel, Field, EmailStr
from sqlalchemy.ext.asyncio import AsyncSession

from ...core.application import AddRouter
from ...core.security.token_creation import create_token, decode_token, set_refresh_cookie
from ...core.errors import create_response_dict
from ...db.postgress.engine import getSession as GetSession
from ...db.postgress.repositories.user import get_user_by_email, verify_user, update_ver_details
from ...db.postgress.repositories.revoked_jwt_tokens import revoke_token, get_revoked_token_by_jti
from ...db.postgress.repositories.acc_recovery import get_acc_recovery_by_token, create_acc_recovery, del_acc_recovery
from ...services.mail.repositories.reset_password import send_reset_password_email
from ...services.mail.repositories.verify_account import send_verification_email

class ResetRequestForm(BaseModel):
    email: EmailStr

class ResendRequestForm(BaseModel):
    email: EmailStr = Field(..., title="The email of the user.", description="The email of the user.")

router = APIRouter(prefix="/recovery", tags=["Account Recovery"])

@router.post("/request-password-reset", responses={200: {"message": "Password reset email sent."}})
async def try_reset_password(request: Request, form: ResetRequestForm, session: AsyncSession = Depends(GetSession)):
    """
    Initiate a password reset for a user.
    """
    user = await get_user_by_email(session, form.email, lazy=False)
    if not user:
        raise HTTPException(status_code=404, detail="User not found.")
    reset = await create_acc_recovery(session, user)
    if not reset:
        raise HTTPException(status_code=500, detail="An error occurred while creating the password reset.")
    try:
        await send_reset_password_email(user, reset)
    except Exception as e:
        await del_acc_recovery(session, reset)
        if getenv("MODE", False) == "DEV":
            raise # propagate the error
        raise HTTPException(status_code=500, detail="An error occurred while sending the password reset email.")
    return {"message": "Password reset email sent."}

@router.post("/resend-verification-email", response_model=dict,
responses={200: {"message": "Verification email sent."}})
async def resend_verification_email(request: Request, form: ResendRequestForm, session: AsyncSession = Depends(GetSession)):
    """
    Resend the verification email to a user.
    """
    user = await get_user_by_email(session, form.email, load_type="eager")
    if not user:
        raise HTTPException(status_code=404, detail="User not found.")
    if user.verified:
        return {"message": "User is already verified."}
    try:
        if not await send_verification_email(user, user.verification_details):
            raise HTTPException(status_code=500, detail="An error occurred while sending the verification email.")
    except Exception as e:
        if getenv("MODE", False) == "DEV":
            raise # propagate the error
    user.verification_details
    return {"message": "Verification email sent."}

AddRouter(router)  # Add the router to the server

router = APIRouter(prefix="/auth", tags=["Email Verification"])

class VerificationResponse(BaseModel):
    message: str = Field(..., description="Verification message")
    access_token: str = Field(None, description="JWT access token if auto-login is enabled")

# Verification endpoint for email link click
@router.get("/verify", response_model=VerificationResponse)
async def verify_email(
    code: str = Query(..., description="Verification code sent to user's email"),
    auto_login: bool = Query(False, description="Whether to automatically log in the user after verification"),
    redirect_url: str = Query(None, description="URL to redirect to after verification"),
    session: AsyncSession = Depends(GetSession),
    response: Response = None
):
    """
    Verify a user's email address using the verification code sent to their email.

    - If auto_login is True, returns access token and sets refresh token cookie
    - If redirect_url is provided, redirects to that URL after verification
    """
    # Verify the user using the verification code
    user = await verify_user(session, code)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired verification code"
        )

    result = {"message": "Email verified successfully"}

    # Auto-login if requested
    if auto_login:
        access_token = create_token(user.id, user.role_id, refresh=False, fresh=True)
        refresh_token = create_token(user.id, user.role_id, refresh=True, fresh=True)

        # Set refresh token in HTTP-only cookie
        if response:
            set_refresh_cookie(response, refresh_token)

        result["access_token"] = access_token

    # Redirect if URL provided
    if redirect_url:
        # Build redirect URL with query parameters
        query_params = f"verified=true"
        if auto_login and "access_token" in result:
            query_params += f"&access_token={result['access_token']}"

        redirect_to = f"{redirect_url}?{query_params}"
        return RedirectResponse(url=redirect_to)

    return result

# Alternative endpoint for frontend verification (AJAX calls)
@router.post("/verify-code", response_model=VerificationResponse)
async def verify_email_code(
    code: str = Query(..., description="Verification code sent to user's email"),
    auto_login: bool = Query(True, description="Whether to automatically log in the user after verification"),
    session: AsyncSession = Depends(GetSession),
    response: Response = None
):
    """
    Verify a user's email address using the verification code.
    This endpoint is meant for frontend applications to verify email through AJAX calls.

    If auto_login is True (default), returns access token and sets refresh token cookie.
    """
    # Verify the user using the verification code
    user = await verify_user(session, code)

    if not user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid or expired verification code"
        )

    result = {"message": "Email verified successfully"}

    # Auto-login if requested
    if auto_login:
        access_token = create_token(user.id, user.role_id, refresh=False, fresh=True)
        refresh_token = create_token(user.id, user.role_id, refresh=True, fresh=True)

        # Set refresh token in HTTP-only cookie
        if response:
            set_refresh_cookie(response, refresh_token)

        result["access_token"] = access_token

    return result

AddRouter(router)


## app/services/__init__.py
# this is blank because you should not group services in a single module

## app/services/mail/__init__.py
from .repositories import *

# only the repositories are imported(actions only)

## app/services/mail/config.py
from os import getenv

from fastapi_mail import FastMail, MessageSchema, ConnectionConfig
from pydantic import BaseModel, EmailStr

class MailConfig(BaseModel):
    MAIL_USERNAME: str
    MAIL_PASSWORD: str
    MAIL_FROM: EmailStr
    MAIL_PORT: int
    MAIL_SERVER: str
    MAIL_STARTTLS: bool
    MAIL_SSL_TLS: bool

def get_mail_config():
    if getenv("MODE") == "DEV":
        return MailConfig(
            MAIL_USERNAME=getenv("MAIL_USERNAME"),
            MAIL_PASSWORD=getenv("MAIL_PASSWORD"),
            MAIL_FROM=getenv("MAIL_FROM"),
            MAIL_PORT=int(getenv("MAIL_PORT")),
            MAIL_SERVER=getenv("MAIL_SERVER"),
            MAIL_STARTTLS=getenv("MAIL_STARTTLS", "false").lower() == 'true',
            MAIL_SSL_TLS=getenv("MAIL_SSL_TLS", "false").lower() == 'true'
        )
    else:
        raise ValueError("Email configuration not set for production")

mail_config = get_mail_config()

conf = ConnectionConfig(
    MAIL_USERNAME=mail_config.MAIL_USERNAME,
    MAIL_PASSWORD=mail_config.MAIL_PASSWORD,
    MAIL_FROM=mail_config.MAIL_FROM,
    MAIL_PORT=mail_config.MAIL_PORT,
    MAIL_SERVER=mail_config.MAIL_SERVER,
    MAIL_STARTTLS=mail_config.MAIL_STARTTLS,
    MAIL_SSL_TLS=mail_config.MAIL_SSL_TLS,
    USE_CREDENTIALS=True,
    VALIDATE_CERTS=True
)

mail = FastMail(conf)


## app/services/mail/repositories/reset_password.py
import os

from jinja2 import Environment, FileSystemLoader
from pydantic import EmailStr
from fastapi_mail import MessageSchema

from ....db.postgress.models.test_model import User, AccountRecovery
from ..config import mail

from os import getenv

template_env = Environment(loader=FileSystemLoader("mail/templates"))

RESET_URL = getenv("RESET_URL", "http://localhost:5000/auth/reset-password")

async def send_reset_password_email(user: User, reset: AccountRecovery, email: str = None):
    """
    Send a reset password email to the user.
    """
    if email is None:
        email = user.email
    reset_url = RESET_URL + f"?token={reset.reset_token}"
    template = template_env.get_template("password_reset.html")
    # Render the template with dynamic content
    html_content = template.render(username=user.username, reset_url=reset_url)

    # Create the email message
    message = MessageSchema(
        subject="Reset Your Password",
        recipients=[email],
        body=html_content,
        subtype="html",
    )
    try:
        await mail.send_message(message)
        return True
    except Exception as e:
        print(f"An error occurred while sending the reset password email: {e}")
        return False
    assert False, "Never should reach this line"


## app/services/mail/repositories/verify_account.py
import os

from jinja2 import Environment, FileSystemLoader
from pydantic import EmailStr
from fastapi_mail import MessageSchema

from ....db.postgress.models.test_model import User, UnverifiedDetails
from ..config import mail

current_dir = os.path.dirname(os.path.abspath(__file__))
# Navigate up one level to the mail directory, then to templates
template_path = os.path.join(current_dir, "..", "templates")
template_env = Environment(loader=FileSystemLoader(template_path))

VER_URL = os.getenv("VER_URL", "http://localhost:5000/auth/verify")

async def send_verification_email(user: User, details: UnverifiedDetails, email: str = None):
    """
    Send a verification email to the user.
    """
    if email is None:
        email = user.email
    verification_url = VER_URL + f"?code={details.verification_token}"
    template = template_env.get_template("account_verification.html")
    # Render the template with dynamic content
    html_content = template.render(username=user.username, verification_url=verification_url)

    # Create the email message
    message = MessageSchema(
        subject="Verify Your Account",
        recipients=[email],
        body=html_content,
        subtype="html",
    )
    try:
        await mail.send_message(message)
        return True
    except Exception as e:
        print(f"An error occurred while sending the verification email: {e}")
        return False
    assert False, "Never should reach this line"

## app/services/mail/repositories/__init__.py
from .reset_password import *
from .verify_account import *

## app/services/content/__init__.py
from .terms import *

## app/services/content/terms.py
"""
Initialize the first version of the Terms and Conditions in the database.
"""

import asyncio
from os import getenv

from sqlalchemy.ext.asyncio import AsyncSession

from ...db.postgress.engine import getSession
from ...db.postgress.repositories.terms_agreements import create_terms_version

# Sample Terms and Conditions content for the first version
INITIAL_TERMS_CONTENT = """
# Terms and Conditions

## 1. Introduction

Welcome to Autrement Capable! These Terms and Conditions govern your use of our platform.

## 2. Acceptance of Terms

By accessing or using Autrement Capable, you agree to be bound by these Terms and Conditions.

## 3. User Accounts

When you create an account with us, you must provide accurate information.

## 4. Privacy Policy

Your privacy is important to us. Please refer to our Privacy Policy for information on how we collect and use your data.

## 5. User Content

You are responsible for all content you provide to the platform.

## 6. Termination

We reserve the right to terminate your access to the platform for violations of these terms.

## 7. Changes to Terms

We may modify these terms at any time. Your continued use of the platform constitutes acceptance of the updated terms.

## 8. Contact Information

If you have any questions about these Terms, please contact us.
"""

async def init_terms():
    """Initialize the first version of the Terms and Conditions."""
    if getenv("MODE") == "DEV":
        # print("Skipping terms initialization in DEV mode.")
        # return
        pass
    session = await getSession()
    try:
        # Create first version
        terms = await create_terms_version(
            session, 
            version="v1.0", 
            content=INITIAL_TERMS_CONTENT,
            is_active=True
        )
        if terms:
            print(f"Terms created: Version {terms.version}")
        else:
            print("Failed to create terms")
    finally:
        await session.close()



## app/services/auth/password.py
import secrets

from passlib.hash import pbkdf2_sha256

def hash_password(password) -> str:
    """Hash a password using pbkdf2_sha256.

    Args:
        password (str): The password to hash.

    Returns:
        str: The hashed password.
    """
    salt = secrets.token_hex(16)
    # convert the salt to bytes
    salt = salt.encode('utf-8')
    hash_value = pbkdf2_sha256.hash(password, salt=salt)
    return f"{hash_value}"

def verify_password(password, hash) -> bool:
    """Verify a password against a hash.

    Args:
        password (str): The password to verify.
        hash (str): The hash to verify against.

    Returns:
        bool: Whether the password is valid or not.
    """
    try:
        return pbkdf2_sha256.verify(password, hash)
    except Exception as e:
        print(e)
        return False

## app/services/auth/__init__.py
from .password import *
from .roles import *
from .verification import *
from .webauthn import *

## app/services/auth/roles.py
import copy

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from ...db.postgress.models import Role

roles = {
    "Super Admin": {
        "description": "Full system access for technical maintenance.",
        "role_id": 1
    },
    "Admin": {
        "description": "Manage users and platform configurations.",
        "role_id": 2
    },
    "Moderator": {
        "description": "Oversee community interactions and enforce guidelines.",
        "role_id": 3
    },
    "Accompagnateur": {
        "description": "Provide support and guidance to young persons.",
        "role_id": 4
    },
    "Expert": {
        "description": "Offer specialized insights and training content.",
        "role_id": 5
    },
    "Professional": {
        "description": "Provide job opportunities and professional advice.",
        "role_id": 6
    },
    "Parent": {
        "description": "Support and monitor their child's progress.",
        "role_id": 7
    },
    "Young Person": {
        "description": "Primary users seeking support and integration.",
        "role_id": 8
    },
    "Guest": { # not using this role for now
        "description": "Limited access to public features and information.",
        "role_id": 9
    }
}

async def init_roles(session: AsyncSession):
    """ Initialize the roles in the database. Skip roles that already exist."""
    try:
        statement = select(Role.role_name)
        result = await session.execute(statement)
        existing_role_names = {row[0] for row in result.all()}
        
        # Create a deep copy of the roles dictionary
        roles_to_add = copy.deepcopy(roles)
        
        # Remove roles that already exist
        for role_name in existing_role_names:
            roles_to_add.pop(role_name, None)
        
        # If all roles exist, return True
        if not roles_to_add:
            return True
        
        # Add the remaining roles to the database
        new_roles = [Role(role_name=role_name, description=role_data["description"]) for role_name, role_data in roles_to_add.items()]
        session.add_all(new_roles)
        await session.commit()
        return True
    except Exception as e:
        print(e)
        await session.rollback()
        return False

## app/services/auth/verification.py
import hmac
import hashlib
import base64
from os import getenv
from datetime import datetime, timedelta
import random
import string
from typing import Union

SERVER_SECRET = getenv("SERVER_SECRET", "default_secret_key")

def generate_verification_code(data: Union[str, int], expiration_seconds: int = 900) -> tuple[str, datetime]:
    """
    Generate a secure verification code based on either:
      - a string (e.g., email or user ID), or
      - an integer length (random code generation),
    combined with an expiration timestamp to ensure uniqueness.

    Args:
        data (Union[str, int]):
            - str: user identifier (e.g., email)
            - int: desired length of random string
        expiration_seconds (int, optional): Expiration time in seconds. Default is 900 (15 min).

    Returns:
        tuple[str, datetime]: (Generated verification code, expiration timestamp)
    """
    # Determine input base
    if isinstance(data, int):
        base = ''.join(random.choices(string.ascii_letters + string.digits, k=data))
    elif isinstance(data, str):
        base = data
    else:
        raise ValueError("data must be a string (email/identifier) or an integer (length of random code)")

    # Generate expiration datetime
    expiration_dt = datetime.utcnow() + timedelta(seconds=expiration_seconds)
    expiration_str = expiration_dt.isoformat()

    # Create message and HMAC signature
    message = f"{base}:{expiration_str}".encode()
    secret = SERVER_SECRET.encode()
    signature = hmac.new(secret, message, hashlib.sha256).digest()

    # Encode to URL-safe base64 (without padding)
    verification_code = base64.urlsafe_b64encode(signature).decode().rstrip("=")

    return verification_code, expiration_dt


def generate_random_suffix(length: int = 6) -> str:
    """
    Generate a random suffix for a the user's username.(Used to avoid conflicts)

    Args:
        length (int, optional): The length of the suffix. Defaults to 6.
    """
    return "".join(random.choices(string.ascii_lowercase + string.digits, k=length))


## app/services/auth/webauthn.py
import base64
import os
import json
from typing import Dict, Any, Optional
from os import getenv
from datetime import datetime, timedelta

from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey
from cryptography.hazmat.primitives import serialization
import cbor2
from webauthn.helpers import bytes_to_base64url, base64url_to_bytes
from webauthn import (
    generate_registration_options,
    verify_registration_response,
    generate_authentication_options,
    verify_authentication_response
)
from webauthn.helpers.structs import (
    AuthenticatorAttachment,
    AuthenticatorSelectionCriteria,
    ResidentKeyRequirement,
    UserVerificationRequirement,
    AttestationConveyancePreference
)

# Get RP name and ID from environment or use defaults
RP_ID = getenv("RP_ID", "localhost")
RP_NAME = getenv("RP_NAME", "Autrement Capable")
ORIGIN = getenv("ORIGIN", f"https://{RP_ID}")

def generate_passkey_registration_options(user_id, username) -> Dict[str, Any]:
    """
    Generate registration options for WebAuthn/Passkey.

    Args:
        user_id (str or int): User ID
        username (str): Username or display name

    Returns:
        Dict[str, Any]: Registration options
    """
    # Convert user_id to string and then to bytes as required by the WebAuthn library
    user_id_str = str(user_id)
    user_id_bytes = user_id_str.encode('utf-8')

    # Generate registration options using proper class instances
    options = generate_registration_options(
        rp_id=RP_ID,
        rp_name=RP_NAME,
        user_id=user_id_bytes,
        user_name=username,
        attestation=AttestationConveyancePreference.DIRECT,
        authenticator_selection=AuthenticatorSelectionCriteria(
            authenticator_attachment=AuthenticatorAttachment.PLATFORM,
            resident_key=ResidentKeyRequirement.PREFERRED,
            user_verification=UserVerificationRequirement.PREFERRED
        )
    )

    # Convert options to dictionary
    try:
        if hasattr(options, 'to_dict'):
            options_dict = options.to_dict()
        elif hasattr(options, 'serialize'):
            options_dict = options.serialize()
        elif hasattr(options, 'asdict'):
            options_dict = options.asdict()
        elif hasattr(options, '__dict__'):
            options_dict = {k: v for k, v in options.__dict__.items() 
                           if not k.startswith('_')}
        else:
            # Manual conversion
            options_dict = {
                'challenge': options.challenge,
                'rp': getattr(options, 'rp', {'name': RP_NAME, 'id': RP_ID}),
                'user': getattr(options, 'user', {'id': user_id_bytes, 'name': username, 'displayName': username}),
                'pubKeyCredParams': getattr(options, 'pub_key_cred_params', []),
                'timeout': getattr(options, 'timeout', 60000),
                'attestation': getattr(options, 'attestation', 'direct'),
                'authenticatorSelection': getattr(options, 'authenticator_selection', {})
            }
    except Exception as e:
        # If conversion fails, create a minimal dictionary with the essentials
        print(f"Error converting options: {e}")
        options_dict = {
            'challenge': options.challenge,
            'rp': {
                'name': RP_NAME,
                'id': RP_ID
            },
            'user': {
                'id': user_id_bytes,
                'name': username,
                'displayName': username
            },
            'pubKeyCredParams': [
                {'type': 'public-key', 'alg': -7},  # ES256
                {'type': 'public-key', 'alg': -257}  # RS256
            ],
            'timeout': 60000,
            'attestation': 'direct',
            'authenticatorSelection': {
                'authenticatorAttachment': 'platform',
                'residentKey': 'preferred',
                'userVerification': 'preferred'
            }
        }

    # Encode challenge as base64url
    options_dict["challenge"] = bytes_to_base64url(options.challenge)

    # Create a new dictionary for the output with the correct structure
    result = {
        'challenge': bytes_to_base64url(options.challenge),
        'rp': {
            'name': options.rp.name,
            'id': options.rp.id
        },
        'user': {
            'id': bytes_to_base64url(options.user.id),
            'name': options.user.name,
            'displayName': options.user.display_name if hasattr(options.user, 'display_name') else options.user.name
        },
        'pubKeyCredParams': [
            {'type': param.type, 'alg': param.alg.value if hasattr(param.alg, 'value') else param.alg}
            for param in options.pub_key_cred_params
        ],
        'timeout': options.timeout,
        'excludeCredentials': [],  # No credentials to exclude for a new user
        'authenticatorSelection': {
            'authenticatorAttachment': options.authenticator_selection.authenticator_attachment.value
                if hasattr(options.authenticator_selection.authenticator_attachment, 'value')
                else options.authenticator_selection.authenticator_attachment,
            'residentKey': options.authenticator_selection.resident_key.value
                if hasattr(options.authenticator_selection.resident_key, 'value')
                else options.authenticator_selection.resident_key,
            'requireResidentKey': options.authenticator_selection.require_resident_key,
            'userVerification': options.authenticator_selection.user_verification.value
                if hasattr(options.authenticator_selection.user_verification, 'value')
                else options.authenticator_selection.user_verification
        },
        'attestation': options.attestation.value if hasattr(options.attestation, 'value') else options.attestation
    }
    return result

def generate_passkey_authentication_options() -> Dict[str, Any]:
    """
    Generate authentication options for WebAuthn/Passkey.

    Returns:
        Dict[str, Any]: Authentication options
    """
    options = generate_authentication_options(
        rp_id=RP_ID,
        user_verification=UserVerificationRequirement.PREFERRED
    )

    # Convert options to dictionary
    try:
        if hasattr(options, 'to_dict'):
            options_dict = options.to_dict()
        elif hasattr(options, 'serialize'):
            options_dict = options.serialize()
        elif hasattr(options, 'asdict'):
            options_dict = options.asdict()
        elif hasattr(options, '__dict__'):
            options_dict = {k: v for k, v in options.__dict__.items() 
                           if not k.startswith('_')}
        else:
            # Manual conversion
            options_dict = {
                'challenge': options.challenge,
                'timeout': getattr(options, 'timeout', 60000),
                'rpId': RP_ID,
                'userVerification': str(UserVerificationRequirement.PREFERRED),
                'allowCredentials': getattr(options, 'allow_credentials', [])
            }
    except Exception as e:
        # Fallback if conversion fails
        print(f"Error converting authentication options: {e}")
        options_dict = {
            'challenge': options.challenge,
            'timeout': 60000,
            'rpId': RP_ID,
            'userVerification': 'preferred',
            'allowCredentials': []
        }

    # Encode challenge as base64url
    options_dict["challenge"] = bytes_to_base64url(options.challenge)

    return options_dict

def verify_passkey_registration(
    user_id: str,
    options_challenge: str,
    registration_data: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """
    Verify WebAuthn/Passkey registration response.

    Args:
        user_id (str): User ID
        options_challenge (str): Challenge from registration options (base64url)
        registration_data (Dict[str, Any]): Registration data from client

    Returns:
        Optional[Dict[str, Any]]: Verified credential data if successful, None if failed
    """
    try:
        # Convert base64url challenge to bytes
        challenge_bytes = base64url_to_bytes(options_challenge)

        # Verify registration response
        verification = verify_registration_response(
            credential=registration_data,
            expected_challenge=challenge_bytes,
            expected_origin=ORIGIN,
            expected_rp_id=RP_ID,
        )

        # If verification successful, return credential data
        if verification and verification.credential_id:
            return {
                "credential_id": bytes_to_base64url(verification.credential_id),
                "public_key": verification.credential_public_key,
                "sign_count": verification.sign_count
            }

        return None
    except Exception as e:
        print(f"Error verifying passkey registration: {e}")
        return None

def verify_passkey_authentication(
    credential_id: str,
    public_key: bytes,
    current_sign_count: int,
    options_challenge: str,
    authentication_data: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """
    Verify WebAuthn/Passkey authentication response.

    Args:
        credential_id (str): Credential ID (base64url)
        public_key (bytes): Public key
        current_sign_count (int): Current sign count
        options_challenge (str): Challenge from authentication options (base64url)
        authentication_data (Dict[str, Any]): Authentication data from client

    Returns:
        Optional[Dict[str, Any]]: Verification result if successful, None if failed
    """
    try:
        # Convert base64url challenge to bytes
        challenge_bytes = base64url_to_bytes(options_challenge)

        # Verify authentication response
        verification = verify_authentication_response(
            credential=authentication_data,
            expected_challenge=challenge_bytes,
            expected_origin=ORIGIN,
            expected_rp_id=RP_ID,
            credential_public_key=public_key,
            credential_current_sign_count=current_sign_count
        )

        # If verification successful, return new sign count
        if verification:
            return {
                "verified": True,
                "new_sign_count": verification.new_sign_count
            }

        return None
    except Exception as e:
        print(f"Error verifying passkey authentication: {e}")
        return None


## app/services/scheduler/factory.py
from typing import Callable

from .base_cron import BaseCronJob, CronJobRegistry
class CronJobFactory:
    """Factory class for dynamically registering cron jobs."""
    # delcare a callback variable type
    add_cron_job: Callable[[Callable], None] = None

    @classmethod
    def register_jobs(cls):
        """Dynamically registers all cron jobs from the registry."""
        for job_cls in CronJobRegistry.get_registered_jobs():
            job_instance = job_cls()  # Create instance
            interval = job_instance.interval  # 🔥 Fetch interval dynamically

            if interval:
                cls.add_cron_job(job_instance.run, trigger="interval", seconds=interval)
                print(f"[CronJobFactory] Registered '{job_instance.name}' every {interval} seconds.")
            else:
                print(f"[CronJobFactory] Warning: No interval set for {job_instance.name}.")

    @classmethod
    def set_add_cron_job(cls, add_cron_job: Callable[[Callable], None]):
        """Set the add_cron_job callback."""
        cls.add_cron_job = add_cron_job
        print(f"[CronJobFactory] add_cron_job callback set.")


## app/services/scheduler/base_cron.py
from abc import ABC, abstractmethod
from typing import Dict, Type

from sqlalchemy.ext.asyncio import AsyncSession

from ...core.config import Config
from ...db.postgress.engine import getSession
from ...utils.patterns import singleton

class BaseCronJob(ABC):
    """Abstract base class for all cron jobs."""

    __config_file__ = "./config/config.yaml"  # Default config file (can be overridden)

    def __init__(self, name: str, config_section: str, config_keys: list[str]):
        """
        Args:
            name (str): The job's unique name.
            config_section (str): The YAML config section to retrieve.
            config_keys (list[str]): The specific keys to retrieve from the section.
        """
        self.name = name
        self.config_section = config_section
        self.config_keys = config_keys
        self.config = self.load_config()
        self.interval = self.config.get(config_keys[0], 60)

    def load_config(self):
        """Loads job-specific configuration from YAML."""
        return Config.get_property(self.__config_file__, self.config_section, self.config_keys)

    @abstractmethod
    async def run(self, session: AsyncSession):
        """Job execution logic (to be overridden)."""
        pass

class CronJobRegistry:
    """Singleton storage for all registered cron jobs."""
    _jobs: Dict[str, Type[BaseCronJob]] = {}

    @classmethod
    def register(cls, job_cls: Type[BaseCronJob], name: str):
        """Registers a cron job class dynamically."""
        job_name = name
        if job_name not in cls._jobs:
            cls._jobs[job_name] = job_cls
            print(f"[CronJobRegistry] Registered job: {job_name}")

    @classmethod
    def get_registered_jobs(cls) -> list[Type[BaseCronJob]]:
        """Returns all registered cron job classes."""
        return list(cls._jobs.values())

def register_cron_job(name: str):
    """Decorator factory to auto-register cron jobs in the registry."""
    def decorator(cls: Type) -> Type:
        CronJobRegistry.register(cls, name)
        return cls  # Return the class unchanged
    return decorator

## app/services/scheduler/__init__.py
from .base_cron import *
from .factory import *

